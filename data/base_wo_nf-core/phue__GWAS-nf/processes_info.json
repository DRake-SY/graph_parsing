{
    "scatterPhenotypes": {
        "name_process": "scatterPhenotypes",
        "string_process": "\nprocess scatterPhenotypes {\n    tag \"$env\"\n\n    echo true\n    publishDir \"${params.outdir}/traits\", mode: 'copy'\n    input:\n        tuple val(env), path(pheno) from ch_pheno\n    output:\n        tuple val(env), path('*.csv') into traits mode flatten optional true\n\n    script:\n        def selection = params.trait ? \"['${params.trait.tokenize(',').join(\"','\")}']\" : \"phenotype.columns\"\n        \"\"\"\n        #!/usr/bin/env python\n\n        import pandas as pd\n\n        phenotype = pd.read_csv(\"${pheno}\", index_col=[0])\n        for trait in ${selection}: \n            try:\n                slice = phenotype[trait].dropna()\n                assert slice.nunique() > 1\n            except KeyError:\n                print(f'Trait {trait} not found in ${pheno.name}. Skipping.')\n            except AssertionError:\n                print(f'Trait values for {trait} are all equal in ${pheno.name}. Skipping.')\n            else:\n                slice.sort_index().to_csv(f'{trait}.csv', header=False)\n        \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "        def selection = params.trait ? \"['${params.trait.tokenize(',').join(\"','\")}']\" : \"phenotype.columns\"\n        \"\"\"\n        #!/usr/bin/env python\n\n        import pandas as pd\n\n        phenotype = pd.read_csv(\"${pheno}\", index_col=[0])\n        for trait in ${selection}: \n            try:\n                slice = phenotype[trait].dropna()\n                assert slice.nunique() > 1\n            except KeyError:\n                print(f'Trait {trait} not found in ${pheno.name}. Skipping.')\n            except AssertionError:\n                print(f'Trait values for {trait} are all equal in ${pheno.name}. Skipping.')\n            else:\n                slice.sort_index().to_csv(f'{trait}.csv', header=False)\n        \"\"\"",
        "nb_lignes_script": 17,
        "language_script": "python",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "ch_pheno"
        ],
        "nb_inputs": 1,
        "outputs": [
            "traits"
        ],
        "nb_outputs": 1,
        "name_workflow": "phue__GWAS-nf",
        "directive": [
            "tag \"$env\"",
            "echo true",
            "publishDir \"${params.outdir}/traits\", mode: 'copy'"
        ],
        "when": "",
        "stub": ""
    },
    "filterGenotypes": {
        "name_process": "filterGenotypes",
        "string_process": "\nprocess filterGenotypes {\n    tag \"$traitname\"\n\n    input:\n        path(geno) from ch_geno.collect()\n        tuple val(env), val(traitname), path(traitfile, stageAs: 'trait*.csv') from ch_traitsplit\n    output:\n        tuple val(env), val(traitname), path('pheno.csv'), path('geno.pkl.xz'), path('kinship.pkl.xz') optional true into ch_filtered\n\n    script:\n        def kinship_mode = params.kinship_from_all_markers ? 'all' : 'filtered'\n        \"\"\"\n        #!/usr/bin/env python\n\n        import h5py\n        import pandas as pd\n        import numpy as np\n        import logging\n\n        from limix.stats import linear_kinship\n\n        logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)\n        logger = logging.getLogger()\n\n        pheno = pd.concat([pd.read_csv(trait, index_col=[0], header=None) for trait in ['${traitfile.join(\"','\")}']], axis=1).dropna()\n        \n        pheno_acc_ids = np.array(pheno.index, dtype=np.uint32)\n\n        # read SNP matrix\n        with h5py.File('${geno}', 'r') as genofile:\n            geno_acc_ids = np.array(genofile['accessions'][:], dtype=np.uint32)\n            snps = np.array(genofile['snps'][:], dtype=bool)\n\n            chr_names = genofile['positions'].attrs.get('chrs')\n            chr_regions = np.array(genofile['positions'].attrs.get('chr_regions'))\n            geno_chroms = []\n            for i, reg in enumerate(chr_regions):\n                geno_chroms.extend(np.repeat(chr_names[i].decode('utf-8'), reg[1]-reg[0]))\n            pos = np.array(genofile['positions'][()], dtype=np.uint32)\n            geno_chroms = np.array(geno_chroms, dtype=np.uint8)\n\n        def get_kinship(snpmat, gower_norm):\n            ibs = linear_kinship(snpmat.to_numpy().T)\n            if gower_norm:\n                from limix.qc import normalise_covariance\n                ibs = normalise_covariance(ibs @ ibs.T)\n            return pd.DataFrame(ibs, index=snpmat.columns, columns=snpmat.columns)\n        \n        genotypes = pd.DataFrame(snps,\n                                 index=pd.MultiIndex.from_arrays([geno_chroms, pos]),\n                                 columns=geno_acc_ids)\n\n        if '${kinship_mode}' == 'all':\n            kinship = get_kinship(genotypes, ${params.normalise_covariance.toString().capitalize()})\n\n        pheno_geno_intersect = np.intersect1d(geno_acc_ids, pheno_acc_ids)\n        \n        phenotypes = pheno.loc[pheno_geno_intersect, :]\n        genotypes = genotypes.loc[:, pheno_geno_intersect]\n        \n        logger.info('%i accessions with both genotype and phenotype. Removed %i accessions because of missing genotype.', len(phenotypes), len(pheno) - len(phenotypes))\n\n        acs = genotypes.sum(axis=1)\n        macs = np.minimum(acs, genotypes.shape[1]-acs)\n        mafs = macs/genotypes.shape[1]\n\n        genotypes = genotypes[mafs >= ${params.maf}]\n\n        logger.info('Removed SNPs not satisfying MAF threshold %d%% (MAC %i). (Remaining SNPs: %i across %i accessions)', ${params.maf}*100, ${params.maf}*genotypes.shape[1], genotypes.shape[0], genotypes.shape[1])\n\n        if '${kinship_mode}' == 'filtered':\n            kinship = get_kinship(genotypes, ${params.normalise_covariance.toString().capitalize()})\n        else:\n            kinship = kinship.loc[genotypes.columns, genotypes.columns]\n\n        if genotypes.shape[0] > 0:\n            phenotypes.to_csv(\"pheno.csv\", header=False)\n            genotypes.to_pickle(\"geno.pkl.xz\")\n            kinship.to_pickle(\"kinship.pkl.xz\")\n        \"\"\"\n}",
        "nb_lignes_process": 80,
        "string_script": "        def kinship_mode = params.kinship_from_all_markers ? 'all' : 'filtered'\n        \"\"\"\n        #!/usr/bin/env python\n\n        import h5py\n        import pandas as pd\n        import numpy as np\n        import logging\n\n        from limix.stats import linear_kinship\n\n        logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)\n        logger = logging.getLogger()\n\n        pheno = pd.concat([pd.read_csv(trait, index_col=[0], header=None) for trait in ['${traitfile.join(\"','\")}']], axis=1).dropna()\n        \n        pheno_acc_ids = np.array(pheno.index, dtype=np.uint32)\n\n        # read SNP matrix\n        with h5py.File('${geno}', 'r') as genofile:\n            geno_acc_ids = np.array(genofile['accessions'][:], dtype=np.uint32)\n            snps = np.array(genofile['snps'][:], dtype=bool)\n\n            chr_names = genofile['positions'].attrs.get('chrs')\n            chr_regions = np.array(genofile['positions'].attrs.get('chr_regions'))\n            geno_chroms = []\n            for i, reg in enumerate(chr_regions):\n                geno_chroms.extend(np.repeat(chr_names[i].decode('utf-8'), reg[1]-reg[0]))\n            pos = np.array(genofile['positions'][()], dtype=np.uint32)\n            geno_chroms = np.array(geno_chroms, dtype=np.uint8)\n\n        def get_kinship(snpmat, gower_norm):\n            ibs = linear_kinship(snpmat.to_numpy().T)\n            if gower_norm:\n                from limix.qc import normalise_covariance\n                ibs = normalise_covariance(ibs @ ibs.T)\n            return pd.DataFrame(ibs, index=snpmat.columns, columns=snpmat.columns)\n        \n        genotypes = pd.DataFrame(snps,\n                                 index=pd.MultiIndex.from_arrays([geno_chroms, pos]),\n                                 columns=geno_acc_ids)\n\n        if '${kinship_mode}' == 'all':\n            kinship = get_kinship(genotypes, ${params.normalise_covariance.toString().capitalize()})\n\n        pheno_geno_intersect = np.intersect1d(geno_acc_ids, pheno_acc_ids)\n        \n        phenotypes = pheno.loc[pheno_geno_intersect, :]\n        genotypes = genotypes.loc[:, pheno_geno_intersect]\n        \n        logger.info('%i accessions with both genotype and phenotype. Removed %i accessions because of missing genotype.', len(phenotypes), len(pheno) - len(phenotypes))\n\n        acs = genotypes.sum(axis=1)\n        macs = np.minimum(acs, genotypes.shape[1]-acs)\n        mafs = macs/genotypes.shape[1]\n\n        genotypes = genotypes[mafs >= ${params.maf}]\n\n        logger.info('Removed SNPs not satisfying MAF threshold %d%% (MAC %i). (Remaining SNPs: %i across %i accessions)', ${params.maf}*100, ${params.maf}*genotypes.shape[1], genotypes.shape[0], genotypes.shape[1])\n\n        if '${kinship_mode}' == 'filtered':\n            kinship = get_kinship(genotypes, ${params.normalise_covariance.toString().capitalize()})\n        else:\n            kinship = kinship.loc[genotypes.columns, genotypes.columns]\n\n        if genotypes.shape[0] > 0:\n            phenotypes.to_csv(\"pheno.csv\", header=False)\n            genotypes.to_pickle(\"geno.pkl.xz\")\n            kinship.to_pickle(\"kinship.pkl.xz\")\n        \"\"\"",
        "nb_lignes_script": 69,
        "language_script": "python",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "ch_geno",
            "ch_traitsplit"
        ],
        "nb_inputs": 2,
        "outputs": [
            "ch_filtered"
        ],
        "nb_outputs": 1,
        "name_workflow": "phue__GWAS-nf",
        "directive": [
            "tag \"$traitname\""
        ],
        "when": "",
        "stub": ""
    },
    "runGWAS": {
        "name_process": "runGWAS",
        "string_process": "\nprocess runGWAS {\n    tag \"$traitname\"\n\n    publishDir \"${params.outdir}/pvals\", mode: 'copy'\n    input:\n        tuple val(env), val(traitname), path(pheno), path(geno), path(kinship) from ch_filtered\n\n    output:\n        tuple val(env), val(traitname), path('*.csv.gz') into ch_pvals mode flatten optional true\n\n    script:\n        def pheno_transform = params.transform == 'no_transformation' ? \"\" : \".apply(${params.transform}, raw=True)\"\n        def locus_fixed = params.locus ? \"genotypes.xs((${params.locus.tokenize(',')[0]},${params.locus.tokenize(',')[1]}), axis=0).to_numpy().ravel()\" : \"None\"\n        if (!params.multitrait)\n            \"\"\"\n            #!/usr/bin/env python\n            \n            import pandas as pd\n            import numpy as np\n\n            from limix.qtl import scan\n            from limix.qc import mean_standardize, quantile_gaussianize, boxcox\n\n            phenotypes = pd.read_csv('${pheno}', index_col=[0], dtype=np.float32, header=None)${pheno_transform}\n\n            pheno = phenotypes.to_numpy(dtype=np.float32)\n\n            genotypes = pd.read_pickle('${geno}')\n            \n            chromosomes = np.array(genotypes.index.get_level_values(0))\n            positions = np.array(genotypes.index.get_level_values(1))\n\n            geno = genotypes.to_numpy().T\n\n            kinship = pd.read_pickle('${kinship}').to_numpy()\n\n            # calculate maf and mac\n            acs = geno.sum(axis=0)\n            macs = np.minimum(acs, geno.shape[0]-acs)\n            mafs = macs/geno.shape[0]\n\n            freq = pd.DataFrame(data={'maf': np.array(mafs), 'mac': np.array(macs)},\n                                index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            st = scan(G=geno,\n                    Y=pheno,\n                    M=${locus_fixed},\n                    K=kinship,\n                    verbose=True)\n\n            effsize = st.effsizes['h2'].loc[st.effsizes['h2']['effect_type'] == 'candidate']\n\n            def phenotypic_variance_explained(beta, beta_se, mafs, n):\n                '''Estimate phenotypic variance explained following Shim et al. (2015) https://doi.org/10.1371/journal.pone.0120758'''\n                return (2 * beta**2 * mafs * (1 - mafs)) / (2 * beta**2 * mafs * (1 - mafs) + beta_se**2 * 2 * n * mafs * (1 - mafs))\n\n            pve = phenotypic_variance_explained(effsize['effsize'].to_numpy(), effsize['effsize_se'].to_numpy(), mafs, pheno.shape[0])\n\n            result = pd.DataFrame(data={'pv': st.stats['pv20'].to_numpy(), 'gve': effsize['effsize'].to_numpy(), 'pve': np.array(pve)},\n                                  index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            if result['pv'].min() < ${params.pthresh}: \n                #result['-log10pv'] = -np.log10(result['pv'])\n                result = result.join(freq)\n                result.to_csv(f'${env}_${traitname}_mac{round(${params.maf}*pheno.shape[0])}.csv.gz', index_label=['chrom', 'pos'], compression='gzip')\n            \"\"\"\n        else\n            \"\"\"\n            #!/usr/bin/env python\n\n            import pandas as pd\n            import numpy as np\n            \n            from limix.qtl import scan\n            from limix.qc import mean_standardize, quantile_gaussianize, boxcox\n\n            phenotypes = pd.read_csv('${pheno}', index_col=[0], dtype=np.float32, header=None)${pheno_transform}\n            \n            pheno = phenotypes.to_numpy(dtype=np.float32)\n            \n            genotypes = pd.read_pickle('${geno}')\n\n            geno = genotypes.to_numpy().T\n\n            kinship = pd.read_pickle('${kinship}')\n            \n            # calculate maf and mac\n            acs = geno.sum(axis=0)\n            macs = np.minimum(acs, geno.shape[0]-acs)\n            mafs = macs/geno.shape[0]\n\n            chromosomes = np.array(genotypes.index.get_level_values(0))\n            positions = np.array(genotypes.index.get_level_values(1))\n\n            freq = pd.DataFrame(data={'maf': np.array(mafs), 'mac': np.array(macs)},\n                                index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            n_pheno = pheno.shape[1]  # number of traits\n\n            A = np.eye(n_pheno)  # p x p matrix of fixed effect sizes\n            # common effects: 1 DoF\n            Asnps0 = np.ones((n_pheno, 1))\n            Asnps = np.eye(n_pheno)\n\n            mtlmm = scan(G=geno,\n                        Y=pheno,\n                        K=kinship,\n                        A=A,\n                        A0=Asnps0,\n                        A1=Asnps,\n                        verbose=True)\n\n            # specific (GxE)\n            specific = pd.DataFrame(mtlmm.stats['pv21'].to_numpy(),\n                                    index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                                    columns=['pv'])                      \n\n            # common (G)\n            common = pd.DataFrame(mtlmm.stats['pv10'].to_numpy(),\n                                  index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                                  columns=['pv'])\n\n            # common (G + GxE)\n            any = pd.DataFrame(mtlmm.stats['pv20'].to_numpy(),\n                               index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                               columns=['pv'])\n\n            results =  {'specific': specific, 'common': common, 'any': any}\n\n            for name, result in results.items():\n                if result['pv'].min() < ${params.pthresh}:\n                    #result['-log10pv'] = -np.log10(result['pv'])\n                    result = result.join(freq)\n                    result.to_csv(f'${traitname}_mac{round(${params.maf}*pheno.shape[0])}_{name}.csv.gz', index_label=['chrom', 'pos'], compression='gzip')\n            \"\"\"\n}",
        "nb_lignes_process": 135,
        "string_script": "        def pheno_transform = params.transform == 'no_transformation' ? \"\" : \".apply(${params.transform}, raw=True)\"\n        def locus_fixed = params.locus ? \"genotypes.xs((${params.locus.tokenize(',')[0]},${params.locus.tokenize(',')[1]}), axis=0).to_numpy().ravel()\" : \"None\"\n        if (!params.multitrait)\n            \"\"\"\n            #!/usr/bin/env python\n            \n            import pandas as pd\n            import numpy as np\n\n            from limix.qtl import scan\n            from limix.qc import mean_standardize, quantile_gaussianize, boxcox\n\n            phenotypes = pd.read_csv('${pheno}', index_col=[0], dtype=np.float32, header=None)${pheno_transform}\n\n            pheno = phenotypes.to_numpy(dtype=np.float32)\n\n            genotypes = pd.read_pickle('${geno}')\n            \n            chromosomes = np.array(genotypes.index.get_level_values(0))\n            positions = np.array(genotypes.index.get_level_values(1))\n\n            geno = genotypes.to_numpy().T\n\n            kinship = pd.read_pickle('${kinship}').to_numpy()\n\n            # calculate maf and mac\n            acs = geno.sum(axis=0)\n            macs = np.minimum(acs, geno.shape[0]-acs)\n            mafs = macs/geno.shape[0]\n\n            freq = pd.DataFrame(data={'maf': np.array(mafs), 'mac': np.array(macs)},\n                                index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            st = scan(G=geno,\n                    Y=pheno,\n                    M=${locus_fixed},\n                    K=kinship,\n                    verbose=True)\n\n            effsize = st.effsizes['h2'].loc[st.effsizes['h2']['effect_type'] == 'candidate']\n\n            def phenotypic_variance_explained(beta, beta_se, mafs, n):\n                '''Estimate phenotypic variance explained following Shim et al. (2015) https://doi.org/10.1371/journal.pone.0120758'''\n                return (2 * beta**2 * mafs * (1 - mafs)) / (2 * beta**2 * mafs * (1 - mafs) + beta_se**2 * 2 * n * mafs * (1 - mafs))\n\n            pve = phenotypic_variance_explained(effsize['effsize'].to_numpy(), effsize['effsize_se'].to_numpy(), mafs, pheno.shape[0])\n\n            result = pd.DataFrame(data={'pv': st.stats['pv20'].to_numpy(), 'gve': effsize['effsize'].to_numpy(), 'pve': np.array(pve)},\n                                  index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            if result['pv'].min() < ${params.pthresh}: \n                #result['-log10pv'] = -np.log10(result['pv'])\n                result = result.join(freq)\n                result.to_csv(f'${env}_${traitname}_mac{round(${params.maf}*pheno.shape[0])}.csv.gz', index_label=['chrom', 'pos'], compression='gzip')\n            \"\"\"\n        else\n            \"\"\"\n            #!/usr/bin/env python\n\n            import pandas as pd\n            import numpy as np\n            \n            from limix.qtl import scan\n            from limix.qc import mean_standardize, quantile_gaussianize, boxcox\n\n            phenotypes = pd.read_csv('${pheno}', index_col=[0], dtype=np.float32, header=None)${pheno_transform}\n            \n            pheno = phenotypes.to_numpy(dtype=np.float32)\n            \n            genotypes = pd.read_pickle('${geno}')\n\n            geno = genotypes.to_numpy().T\n\n            kinship = pd.read_pickle('${kinship}')\n            \n            # calculate maf and mac\n            acs = geno.sum(axis=0)\n            macs = np.minimum(acs, geno.shape[0]-acs)\n            mafs = macs/geno.shape[0]\n\n            chromosomes = np.array(genotypes.index.get_level_values(0))\n            positions = np.array(genotypes.index.get_level_values(1))\n\n            freq = pd.DataFrame(data={'maf': np.array(mafs), 'mac': np.array(macs)},\n                                index=pd.MultiIndex.from_arrays([chromosomes, positions]))\n\n            n_pheno = pheno.shape[1]  # number of traits\n\n            A = np.eye(n_pheno)  # p x p matrix of fixed effect sizes\n            # common effects: 1 DoF\n            Asnps0 = np.ones((n_pheno, 1))\n            Asnps = np.eye(n_pheno)\n\n            mtlmm = scan(G=geno,\n                        Y=pheno,\n                        K=kinship,\n                        A=A,\n                        A0=Asnps0,\n                        A1=Asnps,\n                        verbose=True)\n\n            # specific (GxE)\n            specific = pd.DataFrame(mtlmm.stats['pv21'].to_numpy(),\n                                    index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                                    columns=['pv'])                      \n\n            # common (G)\n            common = pd.DataFrame(mtlmm.stats['pv10'].to_numpy(),\n                                  index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                                  columns=['pv'])\n\n            # common (G + GxE)\n            any = pd.DataFrame(mtlmm.stats['pv20'].to_numpy(),\n                               index=pd.MultiIndex.from_arrays([chromosomes, positions]),\n                               columns=['pv'])\n\n            results =  {'specific': specific, 'common': common, 'any': any}\n\n            for name, result in results.items():\n                if result['pv'].min() < ${params.pthresh}:\n                    #result['-log10pv'] = -np.log10(result['pv'])\n                    result = result.join(freq)\n                    result.to_csv(f'${traitname}_mac{round(${params.maf}*pheno.shape[0])}_{name}.csv.gz', index_label=['chrom', 'pos'], compression='gzip')\n            \"\"\"",
        "nb_lignes_script": 123,
        "language_script": "python",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "ch_filtered"
        ],
        "nb_inputs": 1,
        "outputs": [
            "ch_pvals"
        ],
        "nb_outputs": 1,
        "name_workflow": "phue__GWAS-nf",
        "directive": [
            "tag \"$traitname\"",
            "publishDir \"${params.outdir}/pvals\", mode: 'copy'"
        ],
        "when": "",
        "stub": ""
    },
    "plotGWAS": {
        "name_process": "plotGWAS",
        "string_process": "\nprocess plotGWAS {\n    tag \"$traitname\"\n\n    publishDir \"${params.outdir}/plots\", mode: 'copy',\n        saveAs: { filename ->\n            if (filename.endsWith(\"manhattan.png\")) \"manhattan/$filename\"\n            else if (filename.endsWith(\"qq.png\")) \"qq/$filename\" }\n    input:\n        tuple val(env), val(traitname), path(pvals) from ch_pvals\n\n    output:\n        tuple val(env), val(traitname), path('*manhattan.png'), path('*qq.png') into ch_plots\n\n    script:\n        def effect = params.multitrait ? pvals.baseName.tokenize('_')[-1] : env\n        \"\"\"\n        #!/usr/bin/env python\n\n        import pandas as pd\n        import numpy as np\n        import pylab as plt\n\n        from limix.plot import manhattan, qqplot\n\n        def correct_multiple_tests(pvals, alpha=0.05):\n            c = len(pvals)\n            bonferroni = alpha/c \n            for idx, value in enumerate(sorted(pvals)):\n                benjamini_hochberg = ((idx + 1.0) / float(c)) * alpha\n                if value > benjamini_hochberg:\n                    break\n            return bonferroni, benjamini_hochberg\n\n        result = pd.read_csv('${pvals}')\n\n        bf, bh = correct_multiple_tests(result['pv'])\n        plt.figure(figsize=[15, 4])\n        plt.title(\"${effect}\\\\n${traitname}\")\n        manhattan(result,\n                  colora='#AECF7B',\n                  colorb='#09774D',\n                  pts_kws=dict(markersize=10,\n                               alpha=0.7))\n        plt.axhline(-np.log10(bf), color='gray', linestyle='-', label='Bonferroni')\n        plt.axhline(-np.log10(bh), color='gray', linestyle=':', label='Benjamini-Hochberg')\n        plt.legend(bbox_to_anchor=(0,1), loc='lower left', ncol=2)\n        plt.savefig(\"${pvals.simpleName}_manhattan.png\")\n        plt.figure(figsize=[15, 4])\n        plt.title(\"${effect}\\\\n${traitname}\")\n        qqplot(result['pv'],\n               band_kws=dict(color='#AECF7B',\n                             alpha=0.5),\n               pts_kws=dict(markersize=5,\n                            markeredgecolor='black',\n                            mew=0.5,\n                            color='#09774D'))\n        plt.savefig(\"${pvals.simpleName}_qq.png\")\n        \"\"\"\n}",
        "nb_lignes_process": 58,
        "string_script": "        def effect = params.multitrait ? pvals.baseName.tokenize('_')[-1] : env\n        \"\"\"\n        #!/usr/bin/env python\n\n        import pandas as pd\n        import numpy as np\n        import pylab as plt\n\n        from limix.plot import manhattan, qqplot\n\n        def correct_multiple_tests(pvals, alpha=0.05):\n            c = len(pvals)\n            bonferroni = alpha/c \n            for idx, value in enumerate(sorted(pvals)):\n                benjamini_hochberg = ((idx + 1.0) / float(c)) * alpha\n                if value > benjamini_hochberg:\n                    break\n            return bonferroni, benjamini_hochberg\n\n        result = pd.read_csv('${pvals}')\n\n        bf, bh = correct_multiple_tests(result['pv'])\n        plt.figure(figsize=[15, 4])\n        plt.title(\"${effect}\\\\n${traitname}\")\n        manhattan(result,\n                  colora='#AECF7B',\n                  colorb='#09774D',\n                  pts_kws=dict(markersize=10,\n                               alpha=0.7))\n        plt.axhline(-np.log10(bf), color='gray', linestyle='-', label='Bonferroni')\n        plt.axhline(-np.log10(bh), color='gray', linestyle=':', label='Benjamini-Hochberg')\n        plt.legend(bbox_to_anchor=(0,1), loc='lower left', ncol=2)\n        plt.savefig(\"${pvals.simpleName}_manhattan.png\")\n        plt.figure(figsize=[15, 4])\n        plt.title(\"${effect}\\\\n${traitname}\")\n        qqplot(result['pv'],\n               band_kws=dict(color='#AECF7B',\n                             alpha=0.5),\n               pts_kws=dict(markersize=5,\n                            markeredgecolor='black',\n                            mew=0.5,\n                            color='#09774D'))\n        plt.savefig(\"${pvals.simpleName}_qq.png\")\n        \"\"\"",
        "nb_lignes_script": 43,
        "language_script": "python",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "ch_pvals"
        ],
        "nb_inputs": 1,
        "outputs": [
            "ch_plots"
        ],
        "nb_outputs": 1,
        "name_workflow": "phue__GWAS-nf",
        "directive": [
            "tag \"$traitname\"",
            "publishDir \"${params.outdir}/plots\", mode: 'copy' , saveAs: { filename -> if (filename.endsWith(\"manhattan.png\")) \"manhattan/$filename\" else if (filename.endsWith(\"qq.png\")) \"qq/$filename\" }"
        ],
        "when": "",
        "stub": ""
    }
}