{
    "basecalling": {
        "name_process": "basecalling",
        "string_process": "\nprocess basecalling {\n\tcpus \"${params.guppy_num_callers}\"\n\tlabel \"gpu\"\n\tlabel \"guppy_gpu\"\n\tcontainerOptions '--nv'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.txt'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.log'\n\tinput:\n\t\tpath(fast5_dir)\n\toutput:\n\t\tpath \"sequencing_summary.txt\", emit: sequencing_summary\n\t\tpath \"fastq_runid*fastq\", emit: basecalled_fastq\n\t\tpath(\"*.log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n\twhen:\n\tparams.basecalling & params.gpu & params.demultiplexer == 'qcat'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config ${params.guppy_config_gpu} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 27,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config ${params.guppy_config_gpu} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fast5_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"gpu\"",
            "label \"guppy_gpu\"",
            "containerOptions '--nv'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.txt'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.log'"
        ],
        "when": "params.basecalling & params.gpu & params.demultiplexer == 'qcat'",
        "stub": ""
    },
    "basecalling_single_isolate": {
        "name_process": "basecalling_single_isolate",
        "string_process": "\nprocess basecalling_single_isolate {\n\tcpus \"${params.guppy_num_callers}\"\n\tlabel \"gpu\"\n\tlabel \"guppy_gpu\"\n\tcontainerOptions '--nv'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.txt'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.log'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*fastq.gz'\n\tinput:\n\t\ttuple path(fast5_dir), val(sample)\n\toutput:\n\t\tpath \"sequencing_summary.txt\", emit: sequencing_summary\n\t\tpath \"*fastq.gz\", emit: basecalled_fastq\n\t\tpath(\"*.log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n\twhen:\n\tparams.basecalling & params.gpu & !params.demultiplexing\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config ${params.guppy_config_gpu} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tcat *.fastq > ${sample}.fastq\n\tgzip ${sample}.fastq\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config ${params.guppy_config_gpu} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tcat *.fastq > ${sample}.fastq\n\tgzip ${sample}.fastq\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "sample",
            "fast5_dir"
        ],
        "nb_inputs": 2,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"gpu\"",
            "label \"guppy_gpu\"",
            "containerOptions '--nv'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.txt'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.log'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*fastq.gz'"
        ],
        "when": "params.basecalling & params.gpu & !params.demultiplexing",
        "stub": ""
    },
    "basecalling_cpu": {
        "name_process": "basecalling_cpu",
        "string_process": "\nprocess basecalling_cpu {\n    cpus \"${params.guppy_num_callers}\"\n    label \"cpu\"\n    label \"guppy_cpu\"\n    publishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.txt'\n    publishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.log'\n    input:\n        path(fast5_dir)\n    output:\n    \tpath \"sequencing_summary.txt\", emit: sequencing_summary\n    \tpath \"fastq_runid*fastq\", emit: basecalled_fastq\n\t\tpath(\"*.log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n    when:\n\tparams.basecalling & !params.gpu & params.demultiplexer == 'qcat'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_cpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config ${params.guppy_config_cpu} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_cpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config ${params.guppy_config_cpu} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fast5_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"cpu\"",
            "label \"guppy_cpu\"",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.txt'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.log'"
        ],
        "when": "params.basecalling & !params.gpu & params.demultiplexer == 'qcat'",
        "stub": ""
    },
    "basecalling_cpu_single_isolate": {
        "name_process": "basecalling_cpu_single_isolate",
        "string_process": "\nprocess basecalling_cpu_single_isolate {\n\tcpus \"${params.guppy_num_callers}\"\n\tlabel \"cpu\"\n\tlabel \"guppy_cpu\"\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.txt'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*.log'\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy', pattern: '*fastq.gz'\n\tinput:\n\t\ttuple path(fast5_dir), val(sample)\n\toutput:\n\t\tpath \"sequencing_summary.txt\", emit: sequencing_summary\n\t\tpath \"*fastq.gz\", emit: basecalled_fastq\n\t\tpath(\"*.log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n\twhen:\n\tparams.basecalling & !params.gpu & !params.demultiplexing\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_cpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config ${params.guppy_config_cpu} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tcat *.fastq > ${sample}.fastq\n\tgzip ${sample}.fastq\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_cpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config ${params.guppy_config_cpu} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --flowcell ${params.flowcell} --kit ${params.kit} --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tcat *.fastq > ${sample}.fastq\n\tgzip ${sample}.fastq\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "sample",
            "fast5_dir"
        ],
        "nb_inputs": 2,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"cpu\"",
            "label \"guppy_cpu\"",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.txt'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*.log'",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy', pattern: '*fastq.gz'"
        ],
        "when": "params.basecalling & !params.gpu & !params.demultiplexing",
        "stub": ""
    },
    "demultiplexing_qcat": {
        "name_process": "demultiplexing_qcat",
        "string_process": "\nprocess demultiplexing_qcat {\n\tcpus 1\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/0_basecalling\",  mode: 'copy'\n\tinput:\n\t\tpath(fastq)\n\toutput:\n\t\tpath \"*fastq.gz\", emit: demultiplexed_fastq\n\t\tpath(\"qcat.log\")\n\tpath(\"qcat_version.txt\")\n\twhen:\n\tparams.demultiplexer == 'qcat'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ -d \"${fastq}\" ]] ; then\n\t\tzcat ${fastq}/*q.gz | qcat -b \\$PWD ${params.qcat_args}\n\telse\n\t\tcat ${fastq} | qcat -b \\$PWD ${params.qcat_args}\n\tfi\n\tcp .command.log qcat.log\n\tgzip barcode*fastq \n\tif [[ -f \"none.fastq\" ]] ; then\n\t\tgzip none.fastq\n\tfi\n\tqcat --version > qcat_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 27,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ -d \"${fastq}\" ]] ; then\n\t\tzcat ${fastq}/*q.gz | qcat -b \\$PWD ${params.qcat_args}\n\telse\n\t\tcat ${fastq} | qcat -b \\$PWD ${params.qcat_args}\n\tfi\n\tcp .command.log qcat.log\n\tgzip barcode*fastq \n\tif [[ -f \"none.fastq\" ]] ; then\n\t\tgzip none.fastq\n\tfi\n\tqcat --version > qcat_version.txt\n\t\"\"\"",
        "nb_lignes_script": 13,
        "language_script": "bash",
        "tools": [
            "seqCAT"
        ],
        "tools_url": [
            "https://bio.tools/seqcat"
        ],
        "tools_dico": [
            {
                "name": "seqCAT",
                "uri": "https://bio.tools/seqcat",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "Sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0199",
                            "term": "Genetic variation"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "DNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0199",
                            "term": "DNA variation"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3197",
                                    "term": "Genetic variation analysis"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3197",
                                    "term": "Sequence variation analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3197",
                                    "term": "Variant analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3197",
                                    "term": "Genetic variation annotation"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "This package uses variant calling data (in the form of VCF files) from high throughput sequencing technologies to authenticate and validate the source, function and characteristics of biological samples used in scientific endeavours.",
                "homepage": "http://bioconductor.org/packages/release/bioc/html/seqCAT.html"
            }
        ],
        "inputs": [
            "fastq"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "label \"cpu\"",
            "publishDir \"$params.outdir/0_basecalling\", mode: 'copy'"
        ],
        "when": "params.demultiplexer == 'qcat'",
        "stub": ""
    },
    "basecalling_demultiplexing_guppy": {
        "name_process": "basecalling_demultiplexing_guppy",
        "string_process": "\nprocess basecalling_demultiplexing_guppy {\n\tcpus \"${params.guppy_num_callers}\"\n\tlabel \"gpu\"\n\tlabel \"guppy_gpu\"\n\tcontainerOptions '--nv'\n\tpublishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'\n\tinput:\n\t\tpath(fast5_dir)\n\toutput:\n\t\tpath \"sequencing_summary.txt\", emit: sequencing_summary\n\t\tpath \"*fastq.gz\", emit: demultiplexed_fastq\n\t\tpath(\"*log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n\twhen:\n\tparams.basecalling & params.gpu & params.demultiplexer == 'guppy'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config \"${params.guppy_config_gpu}\" --compress_fastq --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --compress_fastq --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\t\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --config \"${params.guppy_config_gpu}\" --compress_fastq --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --device ${params.guppy_gpu_device} --flowcell ${params.flowcell} --kit ${params.kit} --compress_fastq --num_callers ${params.guppy_num_callers} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\t\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 13,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fast5_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"gpu\"",
            "label \"guppy_gpu\"",
            "containerOptions '--nv'",
            "publishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'"
        ],
        "when": "params.basecalling & params.gpu & params.demultiplexer == 'guppy'",
        "stub": ""
    },
    "basecalling_demultiplexing_guppy_cpu": {
        "name_process": "basecalling_demultiplexing_guppy_cpu",
        "string_process": "\nprocess basecalling_demultiplexing_guppy_cpu {\n\tcpus \"${params.guppy_num_callers}\"\n\tlabel \"cpu\"\n\tlabel \"guppy_cpu\"\n\tpublishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'\n\tinput:\n\t\tpath(fast5_dir)\n\toutput:\n\t\tpath \"sequencing_summary.txt\", emit: sequencing_summary\n\t\tpath \"*fastq.gz\", emit: demultiplexed_fastq\n\t\tpath(\"*log\")\n\t\tpath(\"guppy_basecaller_version.txt\")\n\twhen:\n\tparams.basecalling & !params.gpu & params.demultiplexer == 'guppy'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config \"${params.guppy_config_cpu}\" --compress_fastq --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD  --flowcell ${params.flowcell} --kit ${params.kit} --compress_fastq --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "\t\"\"\"\n\tset +eu\n\tif [[ \"${params.guppy_config_gpu}\" != \"false\" ]] ; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD --config \"${params.guppy_config_cpu}\" --compress_fastq --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\telif [[ \"${params.flowcell}\" != \"false\" ]] && [[ \"${params.kit}\" != \"false\" ]]; then\n\t\tguppy_basecaller -i ${fast5_dir} -s \\$PWD  --flowcell ${params.flowcell} --kit ${params.kit} --compress_fastq --num_callers ${params.guppy_num_callers} --cpu_threads_per_caller ${params.guppy_cpu_threads_per_caller} ${params.guppy_basecaller_args} --barcode_kits ${params.guppy_barcode_kits}\n\tfi\n\tcp .command.log guppy_basecaller.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_basecaller --version > guppy_basecaller_version.txt\n\t\"\"\"",
        "nb_lignes_script": 13,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fast5_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_num_callers}\"",
            "label \"cpu\"",
            "label \"guppy_cpu\"",
            "publishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'"
        ],
        "when": "params.basecalling & !params.gpu & params.demultiplexer == 'guppy'",
        "stub": ""
    },
    "demultiplexing_guppy": {
        "name_process": "demultiplexing_guppy",
        "string_process": "\nprocess demultiplexing_guppy {\n\tcpus \"${params.guppy_barcoder_threads}\"\n\tlabel \"gpu\"\n\tlabel \"guppy_gpu\"\n\tcontainerOptions '--nv'\n\tpublishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'\n\tinput:\n\t\tpath(fastq_dir)\n\toutput:\n\t\tpath \"*fastq.gz\", emit: demultiplexed_fastq\n\t\tpath(\"*log\")\n\t\tpath \"barcoding_summary.txt\"\n\t\tpath(\"guppy_barcoder_version.txt\")\n\twhen:\n\tparams.demultiplexer == 'guppy' & params.demultiplexing & params.gpu\n\tscript:\n\t\"\"\"\n\tset +eu\n\tguppy_barcoder -i ${fastq_dir} -s \\$PWD --device ${params.guppy_gpu_device} --compress_fastq ${params.guppy_barcoder_args} --barcode_kits ${params.guppy_barcode_kits} --worker_threads ${params.guppy_barcoder_threads}\n\tcp .command.log guppy_barcoder.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_barcoder --version > guppy_barcoder_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "\t\"\"\"\n\tset +eu\n\tguppy_barcoder -i ${fastq_dir} -s \\$PWD --device ${params.guppy_gpu_device} --compress_fastq ${params.guppy_barcoder_args} --barcode_kits ${params.guppy_barcode_kits} --worker_threads ${params.guppy_barcoder_threads}\n\tcp .command.log guppy_barcoder.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_barcoder --version > guppy_barcoder_version.txt\n\t\"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fastq_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_barcoder_threads}\"",
            "label \"gpu\"",
            "label \"guppy_gpu\"",
            "containerOptions '--nv'",
            "publishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'"
        ],
        "when": "params.demultiplexer == 'guppy' & params.demultiplexing & params.gpu",
        "stub": ""
    },
    "demultiplexing_guppy_cpu": {
        "name_process": "demultiplexing_guppy_cpu",
        "string_process": "\nprocess demultiplexing_guppy_cpu {\n    cpus \"${params.guppy_barcoder_threads}\"\n    label \"cpu\"\n    label \"guppy_cpu\"\n    publishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'\n    input:\n\t\tpath(fastq_dir)\n    output:\n    \tpath \"*fastq.gz\", emit: demultiplexed_fastq\n\t\tpath(\"*log\")\n\t\tpath \"barcoding_summary.txt\"\n\t\tpath(\"guppy_barcoder_version.txt\")\n\twhen:\n\tparams.demultiplexer == 'guppy' & params.demultiplexing & !params.gpu\n\tscript:\n\t\"\"\"\n\tset +eu\n\tguppy_barcoder -i ${fastq_dir} -s \\$PWD --compress_fastq ${params.guppy_barcoder_args} --barcode_kits ${params.guppy_barcode_kits} --worker_threads ${params.guppy_barcoder_threads}\n\tcp .command.log guppy_barcoder.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_barcoder --version > guppy_barcoder_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 25,
        "string_script": "\t\"\"\"\n\tset +eu\n\tguppy_barcoder -i ${fastq_dir} -s \\$PWD --compress_fastq ${params.guppy_barcoder_args} --barcode_kits ${params.guppy_barcode_kits} --worker_threads ${params.guppy_barcoder_threads}\n\tcp .command.log guppy_barcoder.log\n\tfor dir in barc*/ uncl*/; do\n\t\tbarcode_id=\\${dir%*/}\n\t\tcat \\${dir}/*.fastq.gz > \\${barcode_id}.fastq.gz\n\tdone\n\tguppy_barcoder --version > guppy_barcoder_version.txt\n\t\"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "fastq_dir"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.guppy_barcoder_threads}\"",
            "label \"cpu\"",
            "label \"guppy_cpu\"",
            "publishDir \"$params.outdir/0_demultiplexing\", mode: 'copy'"
        ],
        "when": "params.demultiplexer == 'guppy' & params.demultiplexing & !params.gpu",
        "stub": ""
    },
    "pycoqc": {
        "name_process": "pycoqc",
        "string_process": "\nprocess pycoqc {\n\tcpus 1\n\tlabel \"cpu\"\n\tlabel \"pycoqc\"\n\tpublishDir \"$params.outdir/0_pycoQC\",  mode: 'copy'\n\tinput:\n\t\tpath(sequencing_summary)\n\toutput:\n\t\tpath(\"pycoQC.html\")\n\t\tpath(\"pycoqc_version.txt\")\n\twhen:\n\tparams.basecalling & !params.skip_pycoqc & params.demultiplexer == \"qcat\"\n\tscript:\n\t\"\"\"\n\tset +eu\n\tpycoQC -f ${sequencing_summary} -o \\$PWD/pycoQC.html\n\tpycoQC --version > pycoqc_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 18,
        "string_script": "\t\"\"\"\n\tset +eu\n\tpycoQC -f ${sequencing_summary} -o \\$PWD/pycoQC.html\n\tpycoQC --version > pycoqc_version.txt\n\t\"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "sequencing_summary"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "label \"cpu\"",
            "label \"pycoqc\"",
            "publishDir \"$params.outdir/0_pycoQC\", mode: 'copy'"
        ],
        "when": "params.basecalling & !params.skip_pycoqc & params.demultiplexer == \"qcat\"",
        "stub": ""
    },
    "rasusa": {
        "name_process": "rasusa",
        "string_process": "\nprocess rasusa {\n\tcpus 1\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: \"*.log\", saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), file(long_reads), val(sample), val(genome_size)\n\toutput:\n\t\ttuple val(barcode), file(\"subsampled.fastq.gz\"), val(sample), val(genome_size), emit: subsampled_fastq\n\t\tpath(\"rasusa.log\")\n\t\tpath(\"rasusa_version.txt\")\n\twhen:\n\t!params.skip_rasusa\n\tscript:\n\t\"\"\"\n\tset +eu\n\trasusa --coverage ${params.rasusa_coverage} --genome-size ${genome_size} --input ${long_reads} --output subsampled.fastq.gz\n\tcp .command.log rasusa.log\n\trasusa --version > rasusa_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 21,
        "string_script": "\t\"\"\"\n\tset +eu\n\trasusa --coverage ${params.rasusa_coverage} --genome-size ${genome_size} --input ${long_reads} --output subsampled.fastq.gz\n\tcp .command.log rasusa.log\n\trasusa --version > rasusa_version.txt\n\t\"\"\"",
        "nb_lignes_script": 5,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "genome_size",
            "long_reads"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: \"*.log\", saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "!params.skip_rasusa",
        "stub": ""
    },
    "porechop": {
        "name_process": "porechop",
        "string_process": "\nprocess porechop {\n\tcpus \"${params.porechop_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tlabel \"big_mem\"\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: \"*.log\", saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), file(long_reads), val(sample), val(genome_size)\n\toutput:\n\t\ttuple val(barcode), file(\"trimmed.fastq.gz\"), val(sample), val(genome_size), emit: trimmed_fastq\n\t\tpath(\"porechop.log\")\n\t\tpath(\"porechop_version.txt\")\n\twhen:\n\t!params.skip_porechop\n\tscript:\n\t\"\"\"\n\tset +eu\n\tporechop -i ${long_reads} -t ${params.porechop_threads} -o trimmed.fastq.gz ${params.porechop_args}\n\tcp .command.log porechop.log\n\tporechop --version > porechop_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 22,
        "string_script": "\t\"\"\"\n\tset +eu\n\tporechop -i ${long_reads} -t ${params.porechop_threads} -o trimmed.fastq.gz ${params.porechop_args}\n\tcp .command.log porechop.log\n\tporechop --version > porechop_version.txt\n\t\"\"\"",
        "nb_lignes_script": 5,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "genome_size",
            "long_reads"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.porechop_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "label \"big_mem\"",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: \"*.log\", saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "!params.skip_porechop",
        "stub": ""
    },
    "japsa": {
        "name_process": "japsa",
        "string_process": "\nprocess japsa {\n\tcpus 1\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: '*filtered.fastq.gz', saveAs: { filename -> \"${sample}_$filename\" }\n\tinput:\n\t\ttuple val(barcode), path(trimmed), val(sample), val(genome_size)\n\toutput:\n\t\ttuple val(barcode), path(\"filtered.fastq.gz\"), val(sample), val(genome_size), emit: filtered_fastq\n\twhen:\n\t!params.skip_filtering & params.filtering == 'japsa'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tjsa.np.filter --input ${trimmed} ${params.japsa_args} --output filtered.fastq.gz\n\t\"\"\"\n}",
        "nb_lignes_process": 16,
        "string_script": "\t\"\"\"\n\tset +eu\n\tjsa.np.filter --input ${trimmed} ${params.japsa_args} --output filtered.fastq.gz\n\t\"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "genome_size",
            "trimmed"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: '*filtered.fastq.gz', saveAs: { filename -> \"${sample}_$filename\" }"
        ],
        "when": "!params.skip_filtering & params.filtering == 'japsa'",
        "stub": ""
    },
    "filtlong": {
        "name_process": "filtlong",
        "string_process": "\nprocess filtlong {\n\tcpus 1\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: '*filtered.fastq.gz', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: 'filtlong.log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/1_filtering\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), path(trimmed), val(sample), val(genome_size)\n\toutput:\n\t\ttuple val(barcode), path(\"filtered.fastq.gz\"), val(sample), val(genome_size), emit: filtered_fastq\n\t\tpath(\"*.log\")\n\t\tpath(\"filtlong_version.txt\")\n\twhen:\n\t!params.skip_filtering & params.filtering == 'filtlong'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tfiltlong ${params.filtlong_args} ${trimmed} | gzip > filtered.fastq.gz\n\tcp .command.log filtlong.log\n\tfiltlong --version > filtlong_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 22,
        "string_script": "\t\"\"\"\n\tset +eu\n\tfiltlong ${params.filtlong_args} ${trimmed} | gzip > filtered.fastq.gz\n\tcp .command.log filtlong.log\n\tfiltlong --version > filtlong_version.txt\n\t\"\"\"",
        "nb_lignes_script": 5,
        "language_script": "bash",
        "tools": [
            "Filtlong"
        ],
        "tools_url": [
            "https://bio.tools/Filtlong"
        ],
        "tools_dico": [
            {
                "name": "Filtlong",
                "uri": "https://bio.tools/Filtlong",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0749",
                            "term": "Transcription factors and regulatory sites"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0798",
                            "term": "Mobile genetic elements"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3174",
                            "term": "Metagenomics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Whole genome sequencing"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Genome sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "WGS"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0310",
                                    "term": "Sequence assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3192",
                                    "term": "Sequence trimming"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3482",
                                    "term": "Antimicrobial resistance prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3472",
                                    "term": "k-mer counting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3359",
                                    "term": "Splitting"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3192",
                                    "term": "Trimming"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3359",
                                    "term": "File splitting"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Complete hybrid genome assembly of clinical multidrug-resistant Bacteroides fragilis isolates enables comprehensive identification of antimicrobial-resistance genes and plasmids.\n\nquality filtering tool for long reads.\n\nFiltlong is a tool for filtering long reads by quality. It can take a set of long reads and produce a smaller, better subset. It uses both read length (longer is better) and read identity (higher is better) when choosing which reads pass the filter.\n\n||| CORRECT NAME OF TOOL COULD ALSO BE 'Unicycler' (bio.tools/unicycler), 'Canu-corrected ONT', 'AMR', 'fragilis'",
                "homepage": "https://github.com/rrwick/Filtlong"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "genome_size",
            "trimmed"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: '*filtered.fastq.gz', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: 'filtlong.log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/1_filtering\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "!params.skip_filtering & params.filtering == 'filtlong'",
        "stub": ""
    },
    "flye": {
        "name_process": "flye",
        "string_process": "\nprocess flye {\n\tcpus \"${params.flye_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tlabel \"big_mem\"\n\tpublishDir \"$params.outdir/$sample/2_assembly\",  mode: 'copy', pattern: 'assembly*', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/2_assembly\",  mode: 'copy', pattern: 'flye.log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/2_assembly\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\ttuple val(barcode), path(filtered), val(sample), val(genome_size)\n\toutput:\n\ttuple val(barcode), path(filtered), val(sample), path(\"assembly.fasta\"), path(\"assembly_info.txt\"), path(\"assembly_graph.gfa\"), path(\"assembly_graph.gv\"), emit: assembly_out\n\tpath(\"flye.log\")\n\tpath(\"flye_version.txt\")\n\tscript:\n\t\"\"\"\n\tset +eu\n\tflye --nano-raw ${filtered} --genome-size ${genome_size} --threads ${params.flye_threads} --out-dir \\$PWD ${params.flye_args}\n\tflye -v 2> flye_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 20,
        "string_script": "\t\"\"\"\n\tset +eu\n\tflye --nano-raw ${filtered} --genome-size ${genome_size} --threads ${params.flye_threads} --out-dir \\$PWD ${params.flye_args}\n\tflye -v 2> flye_version.txt\n\t\"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [
            "Flye"
        ],
        "tools_url": [
            "https://bio.tools/Flye"
        ],
        "tools_dico": [
            {
                "name": "Flye",
                "uri": "https://bio.tools/Flye",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Whole genome sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3174",
                            "term": "Metagenomics"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Genome sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "WGS"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0523",
                                    "term": "Mapping assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0524",
                                    "term": "De-novo assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genome assembly"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0523",
                                    "term": "Sequence assembly (mapping assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0524",
                                    "term": "De Bruijn graph"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0524",
                                    "term": "Sequence assembly (de-novo assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Sequence assembly (genome assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genomic assembly"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Flye is a de novo assembler for single molecule sequencing reads, such as those produced by PacBio and Oxford Nanopore Technologies. It is designed for a wide range of datasets, from small bacterial projects to large mammalian-scale assemblies. The package represents a complete pipeline: it takes raw PB / ONT reads as input and outputs polished contigs.",
                "homepage": "https://github.com/fenderglass/Flye"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "genome_size",
            "filtered"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.flye_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "label \"big_mem\"",
            "publishDir \"$params.outdir/$sample/2_assembly\", mode: 'copy', pattern: 'assembly*', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/2_assembly\", mode: 'copy', pattern: 'flye.log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/2_assembly\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "",
        "stub": ""
    },
    "racon_cpu": {
        "name_process": "racon_cpu",
        "string_process": "\nprocess racon_cpu {\n\tcpus \"${params.racon_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix}_${raconv}_${params.racon_nb}.fasta\"}\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(assembly), path(info), path(gfa), path(gv)\n\toutput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(\"${prefix}_${raconv}_${params.racon_nb}.fasta\"), emit: polished_racon\n\t\tpath(\"racon.log\")\n\t\tpath(\"racon_version.txt\")\n\twhen:\n\tparams.polisher == 'medaka'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tln -s ${assembly} ${prefix}_${raconv}_0.fasta\n\tfor i in `seq 1 ${params.racon_nb}`; do\n\t\tii=\\$((\\$i-1))\n\t\tminimap2 -t ${params.racon_threads} -ax map-ont ${prefix}_${raconv}_\\$ii.fasta ${filtered} > ${prefix}.gfa\\$i.sam\n\t\tracon ${params.racon_args} -t ${params.racon_threads} ${filtered} ${prefix}.gfa\\$i.sam ${prefix}_${raconv}_\\$ii.fasta --include-unpolished > ${prefix}_${raconv}_\\$i.fasta\n\t\trm ${prefix}.gfa\\$i.sam\n\t\tpython3 $projectDir/bin/rotate_circular_fasta.py ${prefix}_${raconv}_\\$i.fasta ${info} ${prefix}_${raconv}_\\$i.tmp.fasta\n\t\tcp ${prefix}_${raconv}_\\$i.tmp.fasta ${prefix}_${raconv}_\\$i.fasta\n\tdone\n\tcp .command.log racon.log\n\tracon --version > racon_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "\t\"\"\"\n\tset +eu\n\tln -s ${assembly} ${prefix}_${raconv}_0.fasta\n\tfor i in `seq 1 ${params.racon_nb}`; do\n\t\tii=\\$((\\$i-1))\n\t\tminimap2 -t ${params.racon_threads} -ax map-ont ${prefix}_${raconv}_\\$ii.fasta ${filtered} > ${prefix}.gfa\\$i.sam\n\t\tracon ${params.racon_args} -t ${params.racon_threads} ${filtered} ${prefix}.gfa\\$i.sam ${prefix}_${raconv}_\\$ii.fasta --include-unpolished > ${prefix}_${raconv}_\\$i.fasta\n\t\trm ${prefix}.gfa\\$i.sam\n\t\tpython3 $projectDir/bin/rotate_circular_fasta.py ${prefix}_${raconv}_\\$i.fasta ${info} ${prefix}_${raconv}_\\$i.tmp.fasta\n\t\tcp ${prefix}_${raconv}_\\$i.tmp.fasta ${prefix}_${raconv}_\\$i.fasta\n\tdone\n\tcp .command.log racon.log\n\tracon --version > racon_version.txt\n\t\"\"\"",
        "nb_lignes_script": 13,
        "language_script": "bash",
        "tools": [
            "Minimap2",
            "Racon"
        ],
        "tools_url": [
            "https://bio.tools/minimap2",
            "https://bio.tools/Racon"
        ],
        "tools_dico": [
            {
                "name": "Minimap2",
                "uri": "https://bio.tools/minimap2",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0491",
                                    "term": "Pairwise sequence alignment"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0491",
                                    "term": "Pairwise alignment"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Pairwise aligner for genomic and spliced nucleotide sequences",
                "homepage": "https://github.com/lh3/minimap2"
            },
            {
                "name": "Racon",
                "uri": "https://bio.tools/Racon",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant biology"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Whole genome sequencing"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant science"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plants"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Botany"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "Genome sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3673",
                            "term": "WGS"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genome assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0523",
                                    "term": "Mapping assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3192",
                                    "term": "Sequence trimming"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Sequence assembly (genome assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genomic assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0523",
                                    "term": "Sequence assembly (mapping assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3192",
                                    "term": "Trimming"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "The Possibility to Use Oxford Nanopore Technology | Ultrafast consensus module for raw de novo genome assembly of long uncorrected reads. http://genome.cshlp.org/content/early/2017/01/18/gr.214270.116 Note: This was the original repository which will no longer be officially maintained. Please use the new official repository here: | Racon is intended as a standalone consensus module to correct raw contigs generated by rapid assembly methods which do not include a consensus step | Consensus module for raw de novo DNA assembly of long uncorrected reads",
                "homepage": "https://github.com/isovic/racon"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "assembly",
            "info",
            "gfa",
            "gv"
        ],
        "nb_inputs": 7,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.racon_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix}_${raconv}_${params.racon_nb}.fasta\"}",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "params.polisher == 'medaka'",
        "stub": ""
    },
    "medaka_cpu": {
        "name_process": "medaka_cpu",
        "string_process": "\nprocess medaka_cpu {\n\tcpus \"${params.medaka_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tlabel \"medaka\"\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr}.fasta\"}\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: \"*_version.txt\"\t\n    input:\n\ttuple val(barcode), path(filtered), val(sample), path(draft)\n\toutput:\n\ttuple val(barcode), path(filtered), val(sample), path (\"consensus.fasta\"), emit: polished_medaka\n\tpath(\"medaka.log\")\n\tpath(\"medaka_version.txt\")\n\twhen:\n\tparams.polisher == 'medaka'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tmedaka_consensus -i ${filtered} -d ${draft} -o \\$PWD -t ${params.medaka_threads} -m ${params.medaka_model}\n\trm consensus_probs.hdf calls_to_draft.bam calls_to_draft.bam.bai\n\tcp .command.log medaka.log\n\tmedaka --version > medaka_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 24,
        "string_script": "\t\"\"\"\n\tset +eu\n\tmedaka_consensus -i ${filtered} -d ${draft} -o \\$PWD -t ${params.medaka_threads} -m ${params.medaka_model}\n\trm consensus_probs.hdf calls_to_draft.bam calls_to_draft.bam.bai\n\tcp .command.log medaka.log\n\tmedaka --version > medaka_version.txt\n\t\"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "draft"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.medaka_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "label \"medaka\"",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr}.fasta\"}",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "params.polisher == 'medaka'",
        "stub": ""
    },
    "nextpolish_LR": {
        "name_process": "nextpolish_LR",
        "string_process": "\nprocess nextpolish_LR {\n\tcpus \"${params.nextpolish_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tlabel \"nextpolish\"\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr}.fasta\"}\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(assembly), path(info), path(gfa), path(gv)\n\toutput:\n\t\ttuple val(barcode), path(filtered), val(sample), path (\"${sample}_${prefix_lr}.fasta\"), emit: polished_LR\n\t\tpath(\"nextpolish_LR.log\")\n\t\tpath(\"nextpolish_version.txt\")\n\twhen:\n\tparams.polisher == 'nextpolish'\n\tscript:\n\t\"\"\"\n\tset +eu\n\tls ${filtered} > lgs.fofn\n\techo -e \"task = 55\\ngenome = ${assembly}\\nmultithread_jobs = ${task.cpus}\\nlgs_fofn = lgs.fofn\\nlgs_minimap2_options = -x map-ont -t ${params.nextpolish_threads}\" > nextpolish.cfg\n\tnextPolish nextpolish.cfg\n\tcat 01.lgs_polish/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr}.fasta\n\trm input.lgspart.*.gz\n\trm -r 00.lgs_polish 01.lgs_polish\n\tcp .command.log nextpolish_LR.log\n\tnextPolish --version 2> nextpolish_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 28,
        "string_script": "\t\"\"\"\n\tset +eu\n\tls ${filtered} > lgs.fofn\n\techo -e \"task = 55\\ngenome = ${assembly}\\nmultithread_jobs = ${task.cpus}\\nlgs_fofn = lgs.fofn\\nlgs_minimap2_options = -x map-ont -t ${params.nextpolish_threads}\" > nextpolish.cfg\n\tnextPolish nextpolish.cfg\n\tcat 01.lgs_polish/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr}.fasta\n\trm input.lgspart.*.gz\n\trm -r 00.lgs_polish 01.lgs_polish\n\tcp .command.log nextpolish_LR.log\n\tnextPolish --version 2> nextpolish_version.txt\n\t\"\"\"",
        "nb_lignes_script": 10,
        "language_script": "bash",
        "tools": [
            "NextPolish"
        ],
        "tools_url": [
            "https://bio.tools/NextPolish"
        ],
        "tools_dico": [
            {
                "name": "NextPolish",
                "uri": "https://bio.tools/NextPolish",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant biology"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant science"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plants"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Botany"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genome assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3472",
                                    "term": "k-mer counting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffolding"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Sequence assembly (genome assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genomic assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffold construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffold generation"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "A fast and efficient genome polishing tool for long read assembly.\n\nFast and accurately polish the genome generated by noisy long reads.\n\nNextPolish is used to fix base errors (SNV/Indel) in the genome generated by noisy long reads, it can be used with short read data only or long read data only or a combination of both. It contains two core modules, and use a stepwise fashion to correct the error bases in reference genome. To correct the raw third-generation sequencing (TGS) long reads with approximately 15-10% sequencing errors, please use NextDenovo",
                "homepage": "https://github.com/Nextomics/NextPolish"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "assembly",
            "info",
            "gfa",
            "gv"
        ],
        "nb_inputs": 7,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.nextpolish_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "label \"nextpolish\"",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr}.fasta\"}",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "params.polisher == 'nextpolish'",
        "stub": ""
    },
    "nextpolish": {
        "name_process": "nextpolish",
        "string_process": "\nprocess nextpolish {\n\tcpus \"${params.nextpolish_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tlabel \"nextpolish\"\n\tpublishDir \"$params.outdir/$sample/4_polishing_short_reads\",  mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr_sr}.fasta\"}\n\tpublishDir \"$params.outdir/$sample/4_polishing_short_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/4_polishing_short_reads\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(draft), path(reads_1), path(reads_2)\n\toutput:\n\t\ttuple val(barcode), path(filtered), val(sample), path (\"${sample}_${prefix_lr_sr}_2.fasta\"), emit: polished_SR\n\t\tpath(\"nextpolish.log\")\n\t\tpath(\"nextpolish_version.txt\")\n\twhen:\n\t!params.skip_illumina\n\tscript:\n\t\"\"\"\n\tset +eu\n\tls ${reads_1} ${reads_2} > sgs.fofn\n\techo -e \"task = 1212\\ngenome = ${draft}\\nsgs_fofn = sgs.fofn\\nmultithread_jobs = ${params.nextpolish_threads}\" > nextpolish.cfg\n\tnextPolish nextpolish.cfg\n\tcat 01.kmer_count/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr_sr}_1.fasta\n\tcat 03.kmer_count/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr_sr}_2.fasta\n\trm input.sgspart*.fastq.gz\n\trm -r 00.score_chain 01.kmer_count 02.score_chain 03.kmer_count\n\tcp .command.log nextpolish.log\n\tnextPolish --version 2> nextpolish_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "\t\"\"\"\n\tset +eu\n\tls ${reads_1} ${reads_2} > sgs.fofn\n\techo -e \"task = 1212\\ngenome = ${draft}\\nsgs_fofn = sgs.fofn\\nmultithread_jobs = ${params.nextpolish_threads}\" > nextpolish.cfg\n\tnextPolish nextpolish.cfg\n\tcat 01.kmer_count/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr_sr}_1.fasta\n\tcat 03.kmer_count/*polish.ref.sh.work/polish_genome*/genome.nextpolish.part*.fasta > ${sample}_${prefix_lr_sr}_2.fasta\n\trm input.sgspart*.fastq.gz\n\trm -r 00.score_chain 01.kmer_count 02.score_chain 03.kmer_count\n\tcp .command.log nextpolish.log\n\tnextPolish --version 2> nextpolish_version.txt\n\t\"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [
            "NextPolish"
        ],
        "tools_url": [
            "https://bio.tools/NextPolish"
        ],
        "tools_dico": [
            {
                "name": "NextPolish",
                "uri": "https://bio.tools/NextPolish",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant biology"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant science"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plants"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Botany"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0780",
                            "term": "Plant"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genome assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3472",
                                    "term": "k-mer counting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffolding"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Sequence assembly (genome assembly)"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0525",
                                    "term": "Genomic assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffold construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3216",
                                    "term": "Scaffold generation"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "A fast and efficient genome polishing tool for long read assembly.\n\nFast and accurately polish the genome generated by noisy long reads.\n\nNextPolish is used to fix base errors (SNV/Indel) in the genome generated by noisy long reads, it can be used with short read data only or long read data only or a combination of both. It contains two core modules, and use a stepwise fashion to correct the error bases in reference genome. To correct the raw third-generation sequencing (TGS) long reads with approximately 15-10% sequencing errors, please use NextDenovo",
                "homepage": "https://github.com/Nextomics/NextPolish"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "draft",
            "reads_1",
            "reads_2"
        ],
        "nb_inputs": 6,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.nextpolish_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "label \"nextpolish\"",
            "publishDir \"$params.outdir/$sample/4_polishing_short_reads\", mode: 'copy', pattern: '*fasta', saveAs: { filename -> \"${sample}_${prefix_lr_sr}.fasta\"}",
            "publishDir \"$params.outdir/$sample/4_polishing_short_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/4_polishing_short_reads\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "!params.skip_illumina",
        "stub": ""
    },
    "fixstart": {
        "name_process": "fixstart",
        "string_process": "\nprocess fixstart {\n\tcpus 1\n\tlabel \"circlator\"\n\ttag \"${sample}\"\n\tpublishDir \"$params.outdir/$sample/4_polishing_short_reads\",  mode: 'copy', pattern: '*fixstart.fasta', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/4_polishing_short_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(polished)\n\toutput:\n\t\ttuple val(barcode), path(filtered), val(sample), path (\"${prefix_lr_sr}_fixstart.fasta\"), emit: polished_fixstart \n\t\tpath(\"*log\")\n\tscript:\n\t\"\"\"\n\tset +eu\n\tcirclator fixstart ${params.fixstart_args} ${polished} ${prefix_lr_sr}_fixstart\n\t\"\"\"\n}",
        "nb_lignes_process": 16,
        "string_script": "\t\"\"\"\n\tset +eu\n\tcirclator fixstart ${params.fixstart_args} ${polished} ${prefix_lr_sr}_fixstart\n\t\"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "polished"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "label \"circlator\"",
            "tag \"${sample}\"",
            "publishDir \"$params.outdir/$sample/4_polishing_short_reads\", mode: 'copy', pattern: '*fixstart.fasta', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/4_polishing_short_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }"
        ],
        "when": "",
        "stub": ""
    },
    "fixstart_LR": {
        "name_process": "fixstart_LR",
        "string_process": "\nprocess fixstart_LR {\n\tcpus 1\n\tlabel \"circlator\"\n\ttag \"${sample}\"\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*fixstart.fasta', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/3_polishing_long_reads\",  mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(polished)\n\toutput:\n\t\ttuple val(barcode), path(filtered), val(sample), path (\"${prefix_lr}_fixstart.fasta\"), emit: polished_fixstart \n\t\tpath(\"*log\")\n\tscript:\n\t\"\"\"\n\tset +eu\n\tcirclator fixstart ${params.fixstart_args} ${polished} ${prefix_lr}_fixstart\n\t\"\"\"\n}",
        "nb_lignes_process": 16,
        "string_script": "\t\"\"\"\n\tset +eu\n\tcirclator fixstart ${params.fixstart_args} ${polished} ${prefix_lr}_fixstart\n\t\"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "polished"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus 1",
            "label \"circlator\"",
            "tag \"${sample}\"",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*fixstart.fasta', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/3_polishing_long_reads\", mode: 'copy', pattern: '*log', saveAs: { filename -> \"${sample}_$filename\" }"
        ],
        "when": "",
        "stub": ""
    },
    "quast": {
        "name_process": "quast",
        "string_process": "\nprocess quast {\n\tcpus \"${params.quast_threads}\"\n\ttag \"${sample}\"\n\tlabel \"cpu\"\n\tpublishDir \"$params.outdir/$sample/5_quast\",  mode: 'copy', pattern: 'report*', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/5_quast\",  mode: 'copy', pattern: 'quast.log', saveAs: { filename -> \"${sample}_$filename\" }\n\tpublishDir \"$params.outdir/$sample/5_quast\",  mode: 'copy', pattern: \"*_version.txt\"\n\tinput:\n\t\ttuple val(barcode), path(filtered), val(sample), path(polished)\n\toutput:\n\t\ttuple path(\"report.txt\"), path(\"report.html\"), path(\"report.tsv\"), path(\"report.pdf\"), path(\"quast.log\"), emit: quast_out\n\t\tpath(\"quast_version.txt\")\n\tscript:\n\t\"\"\"\n\tset +eu\n\tquast.py -o \\$PWD -t ${params.quast_threads} -l ${sample} ${polished} ${params.quast_args}\n\tquast --version > quast_version.txt\n\t\"\"\"\n}",
        "nb_lignes_process": 18,
        "string_script": "\t\"\"\"\n\tset +eu\n\tquast.py -o \\$PWD -t ${params.quast_threads} -l ${sample} ${polished} ${params.quast_args}\n\tquast --version > quast_version.txt\n\t\"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [
            "QUAST"
        ],
        "tools_url": [
            "https://bio.tools/quast"
        ],
        "tools_dico": [
            {
                "name": "QUAST",
                "uri": "https://bio.tools/quast",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3180",
                                    "term": "Sequence assembly validation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Visualisation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3180",
                                    "term": "Sequence assembly quality evaluation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3180",
                                    "term": "Assembly QC"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3180",
                                    "term": "Assembly quality evaluation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3180",
                                    "term": "Sequence assembly QC"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Data visualisation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Rendering"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "QUAST stands for QUality ASsessment Tool.  \nIt evaluates a quality of genome assemblies by computing various metrics and providing nice reports.",
                "homepage": "http://quast.sourceforge.net/quast"
            }
        ],
        "inputs": [
            "barcode",
            "sample",
            "filtered",
            "polished"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Vikash84__micropipe",
        "directive": [
            "cpus \"${params.quast_threads}\"",
            "tag \"${sample}\"",
            "label \"cpu\"",
            "publishDir \"$params.outdir/$sample/5_quast\", mode: 'copy', pattern: 'report*', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/5_quast\", mode: 'copy', pattern: 'quast.log', saveAs: { filename -> \"${sample}_$filename\" }",
            "publishDir \"$params.outdir/$sample/5_quast\", mode: 'copy', pattern: \"*_version.txt\""
        ],
        "when": "",
        "stub": ""
    }
}