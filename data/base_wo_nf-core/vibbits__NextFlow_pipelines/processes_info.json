{
    "MOFA": {
        "name_process": "MOFA",
        "string_process": "\nprocess MOFA {\n\n\tstoreDir myData\n\n\toutput:\n\tstdout mofa\n\n\t\"\"\"\n    #!/usr/bin/env Rscript\n\n\tlibrary(Hmisc)\n\tlibrary(WGCNA)\n\tlibrary(pheatmap)\n\tenableWGCNAThreads()\n\n\tsetwd(paste0(\"$myDir\",\"/data\"))\n\tgetwd()\n\n\tfiles <- list.files(pattern = \"*.csv\")\n\tprint(files)\n\n    i <- 1\n    setnames <- c()\n    superset <- list()\n\n\n\tfor (file in files) {\n\n    \tsetnames[i] <- gsub(\".csv\", \"\", file)\n    \tdata <- read.csv(file,row.names=1, comment.char=\"\", colClasses=c(\"character\",rep(\"numeric\",9)), strip.white=FALSE)\n    \tdataExpr = as.data.frame(t(data))\n\n    \tgsg = goodSamplesGenes(dataExpr, verbose = 3);\n    \tif (!gsg\\$allOK) {\n\t\t  # Optionally, print the gene and sample names that were removed:\n\t\t  if (sum(!gsg\\$goodGenes) > 0)\n\t\t    printFlush(paste(\"Removing genes:\", paste(names(dataExpr)[!gsg\\$goodGenes], collapse = \", \")));\n\t\t  if (sum(!gsg\\$goodSamples) > 0)\n\t\t    printFlush(paste(\"Removing samples:\", paste(rownames(dataExpr)[!gsg\\$goodSamples], collapse = \", \")));\n\t\t  # Remove the offending genes and samples from the data:\n\t\t  dataExpr = dataExpr[gsg\\$goodSamples, gsg\\$goodGenes]\n\t\t  data = as.data.frame(t(dataExpr))\n\t\t}\n\n\t\tsuperset[[i]] <- data\n\n    \ti <- i + 1\n    }\n\n\n\n    names(superset) = setnames\n\n\n\tlibrary(MOFAtools)\n\tlibrary(magrittr)\n\tlibrary(Rmisc)\n\n\n\tsetwd(\"$myDir\")\t#storeDir or publishDir won't work\n\tdir.create(\"MOFA\")\n\tsetwd(\"MOFA\")\n\tMOFAobject <- createMOFAobject(superset)\t#the name \"superset\" is used when loading the data\n\tMOFAobject\n\n\tpdf(\"TilesData.pdf\")\n\tplotTilesData(MOFAobject)\n\tdev.off()\n\n\tDataOptions <- getDefaultDataOptions()\n\t\n\tModelOptions <- getDefaultModelOptions(MOFAobject)\n\tModelOptions\\$numFactors <- 25\n\n\n\tTrainOptions <- getDefaultTrainOptions()\n\t#TrainOptions\\$maxiter <- 5\t\t# optional parameter\n\tTrainOptions\\$DropFactorThreshold <- 0.02\n\tTrainOptions\\$seed <- 2017\n\n\tMOFAobject <- prepareMOFA(\n  \t\tMOFAobject, \n  \t\tDataOptions = DataOptions,\n  \t\tModelOptions = ModelOptions,\n  \t\tTrainOptions = TrainOptions\n  \t\t)\n\n  \tMOFAobject\n\n    MOFAobject <- runMOFA(MOFAobject, outfile = \"./MOFAobject\")\n\n    MOFAobject\n    r2 <- calculateVarianceExplained(MOFAobject)\n\tr2\n\t\n\n\tfor (object in viewNames(MOFAobject)) {\n\n\t\tpdf(object)\n\t\tplotWeightsHeatmap(MOFAobject, object, factors=\"all\", show_colnames=F)\n\t\tdev.off()\n\t\t\n\t\tplot2 <- plotWeights(MOFAobject, object, factor = 1)\n\t\tplot3 <- plotTopWeights(MOFAobject, object, 1)\n\t\t\n\t\tpng(paste0(object,\"2\"))\n\t\tmultiplot(plot2,plot3)\n\t\tdev.off()\n\t}\n\n\tif (\"mRNA\" %in% viewNames(MOFAobject)) {\n\t\tdata(\"reactomeGS\")\n\n\n\t\tpdf(\"enrichment\")\n\t\t# perfrom enrichment analysis\n\t\t##################################### CHECKPOINT!!!\n\t\tfsea.out <- runEnrichmentAnalysis(MOFAobject, \"mRNA\", reactomeGS, alpha = 0.01)\n\n\t\tplotEnrichmentBars(fsea.out, alpha=0.01)\n\t\tinterestingFactors <- 4:5\n\t\tfor (factor in interestingFactors) {\n\t\t  lineplot <- plotEnrichment(MOFAobject, fsea.out, factor, alpha=0.01, max.pathways=10)\n\t\t  print(lineplot)\n\t\t}\n\t\t####### NEED TO CHANGE HERE FROM SPECIFIC NAMING TO GENERIC ONES:\n\t\t#Ordination of samples by factors to reveal clusters and graadients in the sample space\n\t\tplotFactorScatter(MOFAobject, factors = 1:2, color_by = \"IGHV\", shape_by = \"trisomy12\")\n\t\tplotFactorScatters(MOFAobject, factors = 1:4, color_by = \"IGHV\")\n\t\t#A single factor can be visualised using the \u2018FactorBeeswarmPlot\u2019 function\n\t\tplotFactorBeeswarm(MOFAobject, factors = 1, color_by = \"IGHV\")\n\t\t##Customized analysis\n\t\t## For customized exploration of weights and factors, you can directly fetch the variables from the model using \u2018get\u2019 functions: \u2018getWeights\u2019, \u2018getFactors\u2019 and \u2018getTrainData\u2019:\n\t\tMOFAweights <- getWeights(MOFAobject, views=\"all\", factors=\"all\", as.data.frame = T)\n\t\thead(MOFAweights)\n\t\tMOFAfactors <- getFactors(MOFAobject, factors=c(1,2), as.data.frame = F)\n\t\thead(MOFAfactors)\n\t\tdev.off()\n\t\t}\n\n\t\"\"\"\n}",
        "nb_lignes_process": 141,
        "string_script": "\"\"\"\n    #!/usr/bin/env Rscript\n\n\tlibrary(Hmisc)\n\tlibrary(WGCNA)\n\tlibrary(pheatmap)\n\tenableWGCNAThreads()\n\n\tsetwd(paste0(\"$myDir\",\"/data\"))\n\tgetwd()\n\n\tfiles <- list.files(pattern = \"*.csv\")\n\tprint(files)\n\n    i <- 1\n    setnames <- c()\n    superset <- list()\n\n\n\tfor (file in files) {\n\n    \tsetnames[i] <- gsub(\".csv\", \"\", file)\n    \tdata <- read.csv(file,row.names=1, comment.char=\"\", colClasses=c(\"character\",rep(\"numeric\",9)), strip.white=FALSE)\n    \tdataExpr = as.data.frame(t(data))\n\n    \tgsg = goodSamplesGenes(dataExpr, verbose = 3);\n    \tif (!gsg\\$allOK) {\n\t\t  # Optionally, print the gene and sample names that were removed:\n\t\t  if (sum(!gsg\\$goodGenes) > 0)\n\t\t    printFlush(paste(\"Removing genes:\", paste(names(dataExpr)[!gsg\\$goodGenes], collapse = \", \")));\n\t\t  if (sum(!gsg\\$goodSamples) > 0)\n\t\t    printFlush(paste(\"Removing samples:\", paste(rownames(dataExpr)[!gsg\\$goodSamples], collapse = \", \")));\n\t\t  # Remove the offending genes and samples from the data:\n\t\t  dataExpr = dataExpr[gsg\\$goodSamples, gsg\\$goodGenes]\n\t\t  data = as.data.frame(t(dataExpr))\n\t\t}\n\n\t\tsuperset[[i]] <- data\n\n    \ti <- i + 1\n    }\n\n\n\n    names(superset) = setnames\n\n\n\tlibrary(MOFAtools)\n\tlibrary(magrittr)\n\tlibrary(Rmisc)\n\n\n\tsetwd(\"$myDir\")\t#storeDir or publishDir won't work\n\tdir.create(\"MOFA\")\n\tsetwd(\"MOFA\")\n\tMOFAobject <- createMOFAobject(superset)\t#the name \"superset\" is used when loading the data\n\tMOFAobject\n\n\tpdf(\"TilesData.pdf\")\n\tplotTilesData(MOFAobject)\n\tdev.off()\n\n\tDataOptions <- getDefaultDataOptions()\n\t\n\tModelOptions <- getDefaultModelOptions(MOFAobject)\n\tModelOptions\\$numFactors <- 25\n\n\n\tTrainOptions <- getDefaultTrainOptions()\n\t#TrainOptions\\$maxiter <- 5\t\t# optional parameter\n\tTrainOptions\\$DropFactorThreshold <- 0.02\n\tTrainOptions\\$seed <- 2017\n\n\tMOFAobject <- prepareMOFA(\n  \t\tMOFAobject, \n  \t\tDataOptions = DataOptions,\n  \t\tModelOptions = ModelOptions,\n  \t\tTrainOptions = TrainOptions\n  \t\t)\n\n  \tMOFAobject\n\n    MOFAobject <- runMOFA(MOFAobject, outfile = \"./MOFAobject\")\n\n    MOFAobject\n    r2 <- calculateVarianceExplained(MOFAobject)\n\tr2\n\t\n\n\tfor (object in viewNames(MOFAobject)) {\n\n\t\tpdf(object)\n\t\tplotWeightsHeatmap(MOFAobject, object, factors=\"all\", show_colnames=F)\n\t\tdev.off()\n\t\t\n\t\tplot2 <- plotWeights(MOFAobject, object, factor = 1)\n\t\tplot3 <- plotTopWeights(MOFAobject, object, 1)\n\t\t\n\t\tpng(paste0(object,\"2\"))\n\t\tmultiplot(plot2,plot3)\n\t\tdev.off()\n\t}\n\n\tif (\"mRNA\" %in% viewNames(MOFAobject)) {\n\t\tdata(\"reactomeGS\")\n\n\n\t\tpdf(\"enrichment\")\n\t\t# perfrom enrichment analysis\n\t\t##################################### CHECKPOINT!!!\n\t\tfsea.out <- runEnrichmentAnalysis(MOFAobject, \"mRNA\", reactomeGS, alpha = 0.01)\n\n\t\tplotEnrichmentBars(fsea.out, alpha=0.01)\n\t\tinterestingFactors <- 4:5\n\t\tfor (factor in interestingFactors) {\n\t\t  lineplot <- plotEnrichment(MOFAobject, fsea.out, factor, alpha=0.01, max.pathways=10)\n\t\t  print(lineplot)\n\t\t}\n\t\t####### NEED TO CHANGE HERE FROM SPECIFIC NAMING TO GENERIC ONES:\n\t\t#Ordination of samples by factors to reveal clusters and graadients in the sample space\n\t\tplotFactorScatter(MOFAobject, factors = 1:2, color_by = \"IGHV\", shape_by = \"trisomy12\")\n\t\tplotFactorScatters(MOFAobject, factors = 1:4, color_by = \"IGHV\")\n\t\t#A single factor can be visualised using the \u2018FactorBeeswarmPlot\u2019 function\n\t\tplotFactorBeeswarm(MOFAobject, factors = 1, color_by = \"IGHV\")\n\t\t##Customized analysis\n\t\t## For customized exploration of weights and factors, you can directly fetch the variables from the model using \u2018get\u2019 functions: \u2018getWeights\u2019, \u2018getFactors\u2019 and \u2018getTrainData\u2019:\n\t\tMOFAweights <- getWeights(MOFAobject, views=\"all\", factors=\"all\", as.data.frame = T)\n\t\thead(MOFAweights)\n\t\tMOFAfactors <- getFactors(MOFAobject, factors=c(1,2), as.data.frame = F)\n\t\thead(MOFAfactors)\n\t\tdev.off()\n\t\t}\n\n\t\"\"\"",
        "nb_lignes_script": 133,
        "language_script": "Rscript",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [
            "mofa"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [
            "storeDir myData"
        ],
        "when": "",
        "stub": ""
    },
    "setter": {
        "name_process": "setter",
        "string_process": "\nprocess setter {\n\toutput:\n\tstdout files\n\n\t\"\"\"\n\t#!/usr/bin/env python\n\n\timport os\n\timport glob\n\tos.chdir(\"{}/data/\".format(\"$myDir\"))\n\tresult = [i for i in glob.glob('*.csv')]\n\tmaxit = len(result)\n\tmySet = []\n\n\tfor x in range(maxit):\n\t\tfor y in range(x + 1, maxit):\n\t\t\tprint (result[x], result[y])\n\n\t\"\"\"\n}",
        "nb_lignes_process": 19,
        "string_script": "\"\"\"\n\t#!/usr/bin/env python\n\n\timport os\n\timport glob\n\tos.chdir(\"{}/data/\".format(\"$myDir\"))\n\tresult = [i for i in glob.glob('*.csv')]\n\tmaxit = len(result)\n\tmySet = []\n\n\tfor x in range(maxit):\n\t\tfor y in range(x + 1, maxit):\n\t\t\tprint (result[x], result[y])\n\n\t\"\"\"",
        "nb_lignes_script": 14,
        "language_script": "python",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [
            "files"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "wgcna": {
        "name_process": "wgcna",
        "string_process": "\nprocess wgcna {\n\tinput:\n\teach x from files.splitText()\n\n\toutput:\n\tstdout test\n\n\t\"\"\"\n\t#!/usr/bin/env Rscript\n\tdir.create(paste0(\"$myDir\",\"/WGCNA\"))\n\tsetwd(paste0(\"$myDir\",\"/WGCNA\"))\n\n\t#####################################\n\t#get filenames\n\t#####################################\n\tlibrary(tools)\n\t\n\tomicsset <- strsplit(trimws(\"$x\"), \" \")\n\n\tomics1 <- omicsset[[1]][1]\n\tomics2 <- omicsset[[1]][2]\n\n\tprint(omics1)\n\tprint(omics2)\n\n\theadDir = paste0(file_path_sans_ext(omics1, compression = FALSE),\"_-_\",file_path_sans_ext(omics2, compression = FALSE))\n\n\n\t############################################################################################################################################################################################\n\t# First part to read and make the data format in the correct format\n\t############################################################################################################################################################################################\n\t# WGCNA tutorial website https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/index.html\n\t\n\t#install.packages(\"Hmisc\")\n\t#install.packages(\"BiocManager\")\n\t#BiocManager::install(\"WGCNA\")\n\n\tlibrary(Hmisc)\n\tlibrary(WGCNA)\n\tlibrary(pheatmap)\n\t#enableWGCNAThreads()\n\t#allowWGCNAThreads() \n\toptions(stringsAsFactors = FALSE)\n\tdir.create(headDir)\n\tsetwd(headDir)\n\tdir.create(\"Figures\")\n\tdir.create(\"Info\")\n\tdir.create(\"ModuleMembership_vs_GeneSignificance\")\n\tdir.create(\"GeneInfo\")\n\tdata = read.csv((paste0(\"$myData\",\"/\",omics1)), header = T);  ## GE matrix ####\n\tdim(data);\n\tnames(data);\n\n\t# The first row of your transposed matrix was rownames of the original matrix, you should first remove them from data,\n\tdataEhsan = data[,-1]\n\t# And then add them as rownames to the new data frame\n\trownames(dataEhsan) = as.character(data[,1])\n\t# And finally transpose it\n\tdatExpr0 = as.data.frame(t(dataEhsan))\n\n\tgsg = goodSamplesGenes(datExpr0, verbose = 3);\n\tgsg\\$allOK # returns FALSE so we clean all bad rows\n\n\tif (!gsg\\$allOK) {\n\t  # Optionally, print the gene and sample names that were removed:\n\t  if (sum(!gsg\\$goodGenes) > 0)\n\t    printFlush(paste(\"Removing genes:\", paste(names(datExpr0)[!gsg\\$goodGenes], collapse = \", \")));\n\t  if (sum(!gsg\\$goodSamples) > 0)\n\t    printFlush(paste(\"Removing samples:\", paste(rownames(datExpr0)[!gsg\\$goodSamples], collapse = \", \")));\n\t  # Remove the offending genes and samples from the data:\n\t  datExpr0 = datExpr0[gsg\\$goodSamples, gsg\\$goodGenes]\n\t}\n\t# Next we cluster the samples (in contrast to clustering genes that will come later) to see for obvious outliers.  \n\n\tsampleTree = hclust(dist(datExpr0), method = \"average\");\n\n\tsizeGrWindow(12,9)\n\tpdf(file = \"Figures/sampleClustering.pdf\", width = 12, height = 9);\n\tpar(cex = 0.6);\n\tpar(mar = c(0,4,2,0))\n\tplot(sampleTree, main = \"Sample clustering to detect outliers\", sub = \"\", xlab = \"\", cex.lab = 1.5,\n\t     cex.axis = 1.5, cex.main = 2)\n\t# Plot a line to show the cut\n\tabline(h = 45000, col = \"red\");\n\tdev.off()\n\n\t###if removing an outlier sample, do it with a height cut-off\n\t#clust = cutreeStatic(sampleTree, cutHeight = 45000, minSize = 10)\n\t#table(clust)\n\t### clust 1 contains the samples we want to keep.\n\t#keepSamples = (clust==1)\n\t#datExpr = datExpr0[keepSamples, ]\n\t# IF NOT REMOVING ANY SAMPLE: \n\tdatExpr = datExpr0\n\tnGenes = ncol(datExpr)\n\tnSamples = nrow(datExpr)\n\t# datExpr; # The variable datExpr now contains the expression data ready for network analysis.\n\n\t# Save and return final data frame ready for analysis\n\tsave(datExpr, file = \"saveToFile.RData\")\n\n\t######################################################\n\t# Use this to parse phenotype data that you want to correlate with the expression data\n\t# Can be metabolite data, individual traits, etc.\n\ttraitData = read.csv((paste0(\"$myData\",\"/\",omics2)), header = TRUE);\n\tdim(traitData)\n\tnames(traitData)\n\trownames(traitData) = traitData[,1];\n\ttraitData = traitData [,-1]\n\tallTraits = t(traitData);\n\n\tMLsamples = rownames(datExpr);\n\n\ttraitRows = match(MLsamples, rownames(allTraits));\n\n\tdatTraits = allTraits[traitRows,];\n\trownames(datTraits) = rownames(allTraits[traitRows,]);\n\tcollectGarbage();\n\t  \n\tsampleTree2 = hclust(dist(datExpr), method = \"average\")\n\t# Convert traits to a color representation: white means low, red means high, grey means missing entry\n\ttraitColors = numbers2colors(datTraits, signed = FALSE);\n\tplotDendroAndColors(sampleTree2, traitColors,\n\t                    groupLabels = names(datTraits),\n\t                    main = \"Sample dendrogram and trait heatmap\")\n\n\tsave(datExpr, datTraits, file = \"01-dataInput.RData\")\n\n\n\n\n\t############################################################################################################################################################################################\n\t# Automatic, one-step network construction and module detection\n\t############################################################################################################################################################################################\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 1\n\t#\n\t#=====================================================================================\n\n\t# Display the current working directory\n\t#getwd();\n\t# If necessary, change the path below to the directory where the data files are stored. \n\t# \".\" means current directory. On Windows use a forward slash / instead of the usual .\n\t#workingDir = \".\";\n\t#setwd(headDir); \n\t# Load the WGCNA package\n\tlibrary(WGCNA)\n\t# The following setting is important, do not omit.\n\toptions(stringsAsFactors = FALSE);\n\t# Allow multi-threading within WGCNA. \n\t# Caution: skip this line if you run RStudio or other third-party R environments.\n\t# See note above.\n\tenableWGCNAThreads()\n\t# Load the data saved in the first part\n\tlnames = load(file = \"01-dataInput.RData\");\n\t# The variable lnames contains the names of loaded variables.\n\tlnames\n\t# Get the number of sets in the multiExpr structure.\n\t# nSets = checkSets(multiExpr)\\$nSets\n\tnSets = 1\n\tmultiExpr = datExpr\n\n\tprint(\"1 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 2\n\t#\n\t#=====================================================================================\n\n\t# Choose a set of soft-thresholding powers\n\tpowers = c(seq(4,10,by=1), seq(12,20, by=2));\n\t# Initialize a list to hold the results of scale-free analysis\n\tpowerTables = vector(mode = \"list\", length = nSets);\n\t# Call the network topology analysis function for each set in turn\n\tfor (set in 1:nSets)\n\t  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr, powerVector=powers,\n\t                                                     verbose = 2)[[2]]);\n\tcollectGarbage();\n\t# Plot the results:\n\tcolors = c(\"black\", \"red\")\n\t# Will plot these columns of the returned scale free analysis tables\n\tplotCols = c(2,5,6,7)\n\tcolNames = c(\"Scale Free Topology Model Fit\", \"Mean connectivity\", \"Median connectivity\",\n\t\"Max connectivity\");\n\t# Get the minima and maxima of the plotted points\n\tylim = matrix(NA, nrow = 2, ncol = 4);\n\tfor (set in 1:nSets){\n\t  for (col in 1:length(plotCols))\n\t  {\n\t    ylim[1, col] = min(ylim[1, col], powerTables[[set]]\\$data[, plotCols[col]], na.rm = TRUE);\n\t    ylim[2, col] = max(ylim[2, col], powerTables[[set]]\\$data[, plotCols[col]], na.rm = TRUE);\n\t  }\n\t}\n\t# Plot the quantities in the chosen columns vs. the soft thresholding power\n\tsizeGrWindow(8, 6)\n\tpdf(file = \"Figures/scaleFreeAnalysis.pdf\", wi = 8, he = 6)\n\tpar(mfcol = c(2,2));\n\tpar(mar = c(4.2, 4.2 , 2.2, 0.5))\n\tcex1 = 0.7;\n\tfor (col in 1:length(plotCols)) for (set in 1:nSets)\n\t{\n\t  if (set==1)\n\t  {\n\t    plot(powerTables[[set]]\\$data[,1], -sign(powerTables[[set]]\\$data[,3])*powerTables[[set]]\\$data[,2],\n\t         xlab = \"Soft Threshold (power)\", ylab = colNames[col],type = \"n\", ylim = ylim[, col],\n\t         main = colNames[col]);\n\t    addGrid();\n\t  }\n\t  if (col==1)\n\t  {\n\t    text(powerTables[[set]]\\$data[,1], -sign(powerTables[[set]]\\$data[,3])*powerTables[[set]]\\$data[,2],\n\t         labels = powers, cex = cex1, col = colors[set]);\n\t  } else\n\t    text(powerTables[[set]]\\$data[,1], powerTables[[set]]\\$data[,plotCols[col]],\n\t         labels = powers, cex = cex1, col = colors[set]);\n\t  # if (col==1)\n\t  # {\n\t  #   legend(\"bottomright\", legend = setLabels, col = colors, pch = 20) ;\n\t  # } else\n\t  #   legend(\"topright\", legend = setLabels, col = colors, pch = 20) ;\n\t}\n\tdev.off();\n\n\tprint(\"2 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 3\n\t#\n\t#=====================================================================================\n\n\t# Form multi-set expression data: columns starting from 9 contain actual expression data.\n\tmultiExpr = vector(mode = \"list\", length = nSets)\n\tmultiExpr[[1]] = list(data = datExpr);\n\tnames(multiExpr[[1]]\\$data) = colnames(datExpr);\n\trownames(multiExpr[[1]]\\$data) = rownames(datExpr);\n\n\n\t# Check that the data has the correct format for many functions operating on multiple sets:\n\texprSize = checkSets(multiExpr)\n\n\tfor (i in 1:ncol(multiExpr[[1]]\\$data)) {\n\t  multiExpr[[1]]\\$data[,i] <- as.numeric(as.character(multiExpr[[1]]\\$data[,i]))\n\t  }\n\n\tsoftTreshold <- 8\n\n\n\tnet <- blockwiseConsensusModules(\n\t        multiExpr, power = softTreshold , minModuleSize = 20, deepSplit = 2,\n\t        pamRespectsDendro = FALSE, \n\t        mergeCutHeight = 0.25, numericLabels = TRUE,\n\t        minKMEtoStay = 0,\n\t        saveTOMs = TRUE, verbose = 5)\n\n\tprint(\"3 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 4\n\t#\n\t#=====================================================================================\n\n\tconsMEs = net\\$multiMEs;\n\tmoduleLabels = net\\$colors;\n\t# Convert the numeric labels to color labels\n\tmoduleColors = labels2colors(moduleLabels)\n\tconsTree = net\\$dendrograms[[1]]; \n\t# saving modules and genes in a table\n\tanno = read.csv(file = \"../../GO/Mouse2GO.csv\", sep = \",\");\n\tanno = anno[,c(1:2)]\n\t# Save annotation and data expression files to .csv file\n\twrite.csv(anno, file = \"Info/anno.csv\", row.names = FALSE)\n\twrite.csv(data\\$X, file = \"Info/datExpr.csv\", row.names = FALSE)\n\n\tt <- colnames(multiExpr[[1]]\\$data)\n\tt <- as.matrix(t)\n\thead(t)\n\tcolnames(t) <- \"GENE\"\n\n\t# Right merge of annotation and data datasets\n\t#genesAnno <- merge(x = anno, y = t, by= \"GENE\" ,all.y = TRUE). # THIS ONE TRIGGERS AN ERROR (OT)\n\tgenesAnno <- merge(x = anno, y = t, by.x= 'gene_id', by.y = 'GENE'  ,all.y = TRUE)\n\n\tgenesAnno <- genesAnno[,c(1:2)]\n\tcolnames(genesAnno) <- c(\"GENES\", \"Annotation\")\n\n\tlibrary(dplyr)\n\n\ttest <- genesAnno %>% group_by(GENES) %>% summarise(Annotations = paste(Annotation, collapse = \", \"))\n\tcolnames(test)\n\n\t# Write text file with genes and corresponding modules and annotations\n\tmod <- data.frame(\"Gene\" = t, \"Modules\" = labels2colors(moduleLabels), \"Annotation\" = test\\$Annotations)\n\tmod <- mod[order(mod\\$Modules),]\n\twrite.table(mod, file = \"Info/ModuleMembers.txt\", row.names = F, sep = \"\\t\", quote = F)\n\n\tsave(consMEs, moduleLabels, moduleColors, consTree, file = \"02-networkConstruction-auto.RData\")\n\n\tprint(\"4 done\")\n\n\t############################################################################################################################################################################################\n\t# 3 - Relating modules to external clinical traits and identifying important genes\n\t############################################################################################################################################################################################\n\n\tprint(\"start part 3\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 1\n\t#\n\t#=====================================================================================\n\n\t# Display the current working directory\n\t#getwd();\n\t# If necessary, change the path below to the directory where the data files are stored. \n\t# \".\" means current directory. On Windows use a forward slash / instead of the usual .\n\tworkingDir = \".\";\n\tsetwd(workingDir); \n\t# Load the WGCNA package\n\tlibrary(WGCNA)\n\t# The following setting is important, do not omit.\n\toptions(stringsAsFactors = FALSE);\n\t# Load the expression and trait data saved in the first part\n\tlnames = load(file = \"01-dataInput.RData\");\n\t#The variable lnames contains the names of loaded variables.\n\tlnames\n\t# Load network data saved in the second part.\n\tlnames = load(file = \"02-networkConstruction-auto.RData\");\n\tlnames\n\n\tprint(\"3.1 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 2\n\t#\n\t#=====================================================================================\n\n\t# Define numbers of genes and samples\n\tnGenes = ncol(datExpr);\n\tnSamples = nrow(datExpr);\n\t# Recalculate MEs with color labels\n\tMEs0 = moduleEigengenes(datExpr, moduleColors)\\$eigengenes\n\tMEs = orderMEs(MEs0)\n\tmoduleTraitCor = cor(MEs, datTraits, use = \"p\");\n\tmoduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);\n\n\twrite.table(moduleTraitCor, file = \"Info/metabolites_transcriptomics_corr_matrix.txt\", row.names = T, sep = \"\\t\", quote = F)\n\n\tprint(\"3.2 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 3\n\t#\n\t#=====================================================================================\n\n\tsizeGrWindow(10,6)\n\t# Will display correlations and their p-values\n\ttextMatrix =  paste(signif(moduleTraitCor, 2), \"\\n(\",\n\t                           signif(moduleTraitPvalue, 1), \")\", sep = \"\");\n\tdim(textMatrix) = dim(moduleTraitCor)\n\t# Display the correlation values within a heatmap plot\n\tpdf(file = \"Figures/Heatmap_metabolites_transcriptomics_corr_matrix.pdf\", wi = 10, he = 6)\n\tpar(mar = c(3, 6, 7, 3));\n\tlabeledHeatmap(Matrix = moduleTraitCor,\n\t               xLabels = colnames(moduleTraitCor),\n\t               xLabelsPosition = \"top\",\n\t               xLabelsAngle = -90,\n\t               yLabels = names(MEs),\n\t               ySymbols = names(MEs),\n\t               colorLabels = FALSE,\n\t               colors = greenWhiteRed(50),\n\t               setStdMargins = FALSE,\n\t               cex.text = 0.5,\n\t               cex.lab.x = 0.45,\n\t               cex.lab.y = 0.3,\n\t               zlim = c(-1,1))\n\ttitle(\"Module-trait relationships\", line = 5)\n\tdev.off()\n\n\tprint(\"3.3 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 4\n\t#\n\t#=====================================================================================\n\n\t# \n\tmetabo = list()\n\tfor (i in colnames(moduleTraitPvalue)) {\n\t  # Define variable meta containing the metabolite columns of datTrait\n\t  meta <- data.frame(datTraits[,i]);\n\t  meta\\$i <- i\n\t  metabo[[i]] <- meta\n\t}\n\n\tmetabol = do.call(cbind, metabo)\n\tmetabol <- metabol[c(T,F)]\n\tcolnames(metabol) = gsub(\".datTraits...i.\", \"\", colnames(metabol))\n\t  \n\t# Names (colors) of the modules\n\tmodNames = substring(names(MEs), 3)\n\tgeneModuleMembership = as.data.frame(cor(datExpr, MEs, use = \"p\"));\n\tMMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples), append = T);\n\n\tnames(geneModuleMembership) = paste(\"MM\", modNames, sep=\"\");\n\tnames(MMPvalue) = paste(\"p.MM\", modNames, sep=\"\");\n\t  \n\tgeneTraitSignificance = as.data.frame(cor(datExpr, metabol, use = \"p\"));\n\tGSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));\n\t  \n\tnames(geneTraitSignificance) = paste(\"GS.\", names(metabol), sep=\"\");\n\tnames(GSPvalue) = paste(\"p.GS.\", names(metabol), sep=\"\");\n\n\tprint(\"3.4 done\")\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 5 \n\t#\n\t#=====================================================================================\n\n\t# Calculate the module membership values (aka. module eigengene based connectivity kME):\n\tdatKME <- signedKME(datExpr, MEs)  # equals geneModuleMembership\n\tcolnames(datKME) <- sub(\"kME\", \"MM.\", colnames(datKME))\n\n\tcolorOfColumn <- substring(names(datKME),4)\n\n\tmetabolites <- colnames(moduleTraitPvalue)\n\tfor (metabolite in metabolites) {\n\t  cat(paste(\"\\nmetabolite:\", metabolite, \"\\n\"))\n\t  pdf(paste0(\"ModuleMembership_vs_GeneSignificance/\", metabolite, \"_ModuleMembershipVsgeneSig.pdf\"))\n\t  par(mar=c(6, 8, 4, 4) + 0.1)\n\t  modNames = substring(names(MEs), 3)\n\t  for (module in modNames) {\n\t    column <- match(module,colorOfColumn)\n\t    moduleGenes <- moduleColors == module;\n\t    GS = paste(\"GS.\", metabolite, sep = \"\")\n\t    verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),\n\t                       abs(geneTraitSignificance[moduleGenes, GS]),\n\t                       xlab = paste(\"Module membership in\", module, \"module\"),\n\t                       ylab = paste(\"Gene significance for\", metabolite),\n\t                       xlim = c(0,1),\n\t                       ylim = c(0,1),\n\t                       main = paste(\"Module membership vs. gene significance\\n\"),\n\t                       cex.main = 1.3,\n\t                       cex.lab = 1.1,\n\t                       cex.axis = 1,\n\t                       pch = 21, \n\t                       col = \"dark gray\", \n\t                       bg = module)\n\t  }\n\t  \n\t  dev.off()\n\t} # end of loop\n\n\tprint(\"3.5 done\")\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 6\n\t#\n\t#=====================================================================================\n\n\n\t# Define top genes for every metabolite in every module \n\ttopGene <- list()\n\ttopGene_ <- list()\n\tfor(metabolite in metabolites) {\n\t  for(module in modNames) {\n\t    GS = paste(\"GS.\", metabolite, sep = \"\")\n\t    MM = paste(\"MM\", module, sep = \"\")\n\t    topGenes = abs(geneModuleMembership[,MM]) > 0.8 & abs(geneTraitSignificance[,GS]) > 0.8\n\t    topGene[[module]] <- topGenes\n\t  }\n\t  topGene_[[metabolite]] <- topGene\n\t} # end of loop\n\n\t# Link with gene names\n\ttopGene2name <- list()\n\ttopGene2name_ <- list()\n\tfor(metabolite in metabolites) {\n\t  for(module in modNames) {\n\t    topGenes2names <- dimnames(datExpr)[[2]][topGene_[[metabolite]][[module]]]\n\t    topGene2name[[module]] <- topGenes2names\n\t  }\n\t  topGene2name_[[metabolite]] <- topGene2name\n\t} # end of loop\n\n\t# Filter empty list \n\tfilterGene1_ <- list()\n\tfor(metabolite in names(topGene2name_)) {\n\t  filter = topGene2name_[[metabolite]][lapply(topGene2name_[[metabolite]],length)>0]\n\t  filterGene1_[[metabolite]] <- filter\n\t} # end of loop\n\n\n\t# Filter empty list \n\tfilterGene_ <- list()\n\tfor (items in filterGene1_){\n\t  filter2 = filterGene1_[lapply(filterGene1_,length)>0]\n\t  filterGene_ <- filter2\n\t}\n\n\tprint(\"3.6 done\")\n\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 7\n\t#\n\t#=====================================================================================\n\n\t# Write output to files\n\tmetabolites2 <-names(filterGene_)\n\tfor(metabolite in metabolites2) {\n\t  modules <-names(filterGene_[[metabolite]])\n\t  GTS <- paste(\"GS.\", metabolite, sep = \"\")\n\t  \n\t  for(module in modules) {\n\t    cat(paste(\"\\nCreating output for top genes in\", module, \"for\", metabolite, \"\\n\"))\n\t    genes <- filterGene_[[metabolite]][[module]]\n\t    GMM = paste(\"MM\", module, sep = \"\")\n\t    # Create the starting data frame\n\t    infoGenes = list(genes = genes,\n\t                           moduleColor = moduleColors[topGene_[[metabolite]][[module]]],\n\t                           annotation = test\\$Annotations[topGene_[[metabolite]][[module]]],\n\t                           geneTraitSignificance = geneTraitSignificance[filterGene_[[metabolite]][[module]], GTS],\n\t                           geneModuleMembership = geneModuleMembership[filterGene_ [[metabolite]][[module]], GMM])\n\t    \n\n\t    # Order the genes in the infoTopGenes variable first by module color, then by geneTraitSignificance\n\t    #geneOrder <- order(infoGenes\\$moduleColor, -abs(infoGenes[,4]))\n\t    #infoGenes = infoGenes[geneOrder, ]\n\t    \n\t    write.csv(infoGenes, file = paste0(\"GeneInfo/\", module, \"_\", metabolite, \"_GeneInfo.csv\"), row.names = FALSE)\n\t  }\n\t} # end of loop\n\n\tprint(\"3.7 done\")\n\n\n\n\t\"\"\"\n}",
        "nb_lignes_process": 553,
        "string_script": "\"\"\"\n\t#!/usr/bin/env Rscript\n\tdir.create(paste0(\"$myDir\",\"/WGCNA\"))\n\tsetwd(paste0(\"$myDir\",\"/WGCNA\"))\n\n\t#####################################\n\t#get filenames\n\t#####################################\n\tlibrary(tools)\n\t\n\tomicsset <- strsplit(trimws(\"$x\"), \" \")\n\n\tomics1 <- omicsset[[1]][1]\n\tomics2 <- omicsset[[1]][2]\n\n\tprint(omics1)\n\tprint(omics2)\n\n\theadDir = paste0(file_path_sans_ext(omics1, compression = FALSE),\"_-_\",file_path_sans_ext(omics2, compression = FALSE))\n\n\n\t############################################################################################################################################################################################\n\t# First part to read and make the data format in the correct format\n\t############################################################################################################################################################################################\n\t# WGCNA tutorial website https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/index.html\n\t\n\t#install.packages(\"Hmisc\")\n\t#install.packages(\"BiocManager\")\n\t#BiocManager::install(\"WGCNA\")\n\n\tlibrary(Hmisc)\n\tlibrary(WGCNA)\n\tlibrary(pheatmap)\n\t#enableWGCNAThreads()\n\t#allowWGCNAThreads() \n\toptions(stringsAsFactors = FALSE)\n\tdir.create(headDir)\n\tsetwd(headDir)\n\tdir.create(\"Figures\")\n\tdir.create(\"Info\")\n\tdir.create(\"ModuleMembership_vs_GeneSignificance\")\n\tdir.create(\"GeneInfo\")\n\tdata = read.csv((paste0(\"$myData\",\"/\",omics1)), header = T);  ## GE matrix ####\n\tdim(data);\n\tnames(data);\n\n\t# The first row of your transposed matrix was rownames of the original matrix, you should first remove them from data,\n\tdataEhsan = data[,-1]\n\t# And then add them as rownames to the new data frame\n\trownames(dataEhsan) = as.character(data[,1])\n\t# And finally transpose it\n\tdatExpr0 = as.data.frame(t(dataEhsan))\n\n\tgsg = goodSamplesGenes(datExpr0, verbose = 3);\n\tgsg\\$allOK # returns FALSE so we clean all bad rows\n\n\tif (!gsg\\$allOK) {\n\t  # Optionally, print the gene and sample names that were removed:\n\t  if (sum(!gsg\\$goodGenes) > 0)\n\t    printFlush(paste(\"Removing genes:\", paste(names(datExpr0)[!gsg\\$goodGenes], collapse = \", \")));\n\t  if (sum(!gsg\\$goodSamples) > 0)\n\t    printFlush(paste(\"Removing samples:\", paste(rownames(datExpr0)[!gsg\\$goodSamples], collapse = \", \")));\n\t  # Remove the offending genes and samples from the data:\n\t  datExpr0 = datExpr0[gsg\\$goodSamples, gsg\\$goodGenes]\n\t}\n\t# Next we cluster the samples (in contrast to clustering genes that will come later) to see for obvious outliers.  \n\n\tsampleTree = hclust(dist(datExpr0), method = \"average\");\n\n\tsizeGrWindow(12,9)\n\tpdf(file = \"Figures/sampleClustering.pdf\", width = 12, height = 9);\n\tpar(cex = 0.6);\n\tpar(mar = c(0,4,2,0))\n\tplot(sampleTree, main = \"Sample clustering to detect outliers\", sub = \"\", xlab = \"\", cex.lab = 1.5,\n\t     cex.axis = 1.5, cex.main = 2)\n\t# Plot a line to show the cut\n\tabline(h = 45000, col = \"red\");\n\tdev.off()\n\n\t###if removing an outlier sample, do it with a height cut-off\n\t#clust = cutreeStatic(sampleTree, cutHeight = 45000, minSize = 10)\n\t#table(clust)\n\t### clust 1 contains the samples we want to keep.\n\t#keepSamples = (clust==1)\n\t#datExpr = datExpr0[keepSamples, ]\n\t# IF NOT REMOVING ANY SAMPLE: \n\tdatExpr = datExpr0\n\tnGenes = ncol(datExpr)\n\tnSamples = nrow(datExpr)\n\t# datExpr; # The variable datExpr now contains the expression data ready for network analysis.\n\n\t# Save and return final data frame ready for analysis\n\tsave(datExpr, file = \"saveToFile.RData\")\n\n\t######################################################\n\t# Use this to parse phenotype data that you want to correlate with the expression data\n\t# Can be metabolite data, individual traits, etc.\n\ttraitData = read.csv((paste0(\"$myData\",\"/\",omics2)), header = TRUE);\n\tdim(traitData)\n\tnames(traitData)\n\trownames(traitData) = traitData[,1];\n\ttraitData = traitData [,-1]\n\tallTraits = t(traitData);\n\n\tMLsamples = rownames(datExpr);\n\n\ttraitRows = match(MLsamples, rownames(allTraits));\n\n\tdatTraits = allTraits[traitRows,];\n\trownames(datTraits) = rownames(allTraits[traitRows,]);\n\tcollectGarbage();\n\t  \n\tsampleTree2 = hclust(dist(datExpr), method = \"average\")\n\t# Convert traits to a color representation: white means low, red means high, grey means missing entry\n\ttraitColors = numbers2colors(datTraits, signed = FALSE);\n\tplotDendroAndColors(sampleTree2, traitColors,\n\t                    groupLabels = names(datTraits),\n\t                    main = \"Sample dendrogram and trait heatmap\")\n\n\tsave(datExpr, datTraits, file = \"01-dataInput.RData\")\n\n\n\n\n\t############################################################################################################################################################################################\n\t# Automatic, one-step network construction and module detection\n\t############################################################################################################################################################################################\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 1\n\t#\n\t#=====================================================================================\n\n\t# Display the current working directory\n\t#getwd();\n\t# If necessary, change the path below to the directory where the data files are stored. \n\t# \".\" means current directory. On Windows use a forward slash / instead of the usual .\n\t#workingDir = \".\";\n\t#setwd(headDir); \n\t# Load the WGCNA package\n\tlibrary(WGCNA)\n\t# The following setting is important, do not omit.\n\toptions(stringsAsFactors = FALSE);\n\t# Allow multi-threading within WGCNA. \n\t# Caution: skip this line if you run RStudio or other third-party R environments.\n\t# See note above.\n\tenableWGCNAThreads()\n\t# Load the data saved in the first part\n\tlnames = load(file = \"01-dataInput.RData\");\n\t# The variable lnames contains the names of loaded variables.\n\tlnames\n\t# Get the number of sets in the multiExpr structure.\n\t# nSets = checkSets(multiExpr)\\$nSets\n\tnSets = 1\n\tmultiExpr = datExpr\n\n\tprint(\"1 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 2\n\t#\n\t#=====================================================================================\n\n\t# Choose a set of soft-thresholding powers\n\tpowers = c(seq(4,10,by=1), seq(12,20, by=2));\n\t# Initialize a list to hold the results of scale-free analysis\n\tpowerTables = vector(mode = \"list\", length = nSets);\n\t# Call the network topology analysis function for each set in turn\n\tfor (set in 1:nSets)\n\t  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr, powerVector=powers,\n\t                                                     verbose = 2)[[2]]);\n\tcollectGarbage();\n\t# Plot the results:\n\tcolors = c(\"black\", \"red\")\n\t# Will plot these columns of the returned scale free analysis tables\n\tplotCols = c(2,5,6,7)\n\tcolNames = c(\"Scale Free Topology Model Fit\", \"Mean connectivity\", \"Median connectivity\",\n\t\"Max connectivity\");\n\t# Get the minima and maxima of the plotted points\n\tylim = matrix(NA, nrow = 2, ncol = 4);\n\tfor (set in 1:nSets){\n\t  for (col in 1:length(plotCols))\n\t  {\n\t    ylim[1, col] = min(ylim[1, col], powerTables[[set]]\\$data[, plotCols[col]], na.rm = TRUE);\n\t    ylim[2, col] = max(ylim[2, col], powerTables[[set]]\\$data[, plotCols[col]], na.rm = TRUE);\n\t  }\n\t}\n\t# Plot the quantities in the chosen columns vs. the soft thresholding power\n\tsizeGrWindow(8, 6)\n\tpdf(file = \"Figures/scaleFreeAnalysis.pdf\", wi = 8, he = 6)\n\tpar(mfcol = c(2,2));\n\tpar(mar = c(4.2, 4.2 , 2.2, 0.5))\n\tcex1 = 0.7;\n\tfor (col in 1:length(plotCols)) for (set in 1:nSets)\n\t{\n\t  if (set==1)\n\t  {\n\t    plot(powerTables[[set]]\\$data[,1], -sign(powerTables[[set]]\\$data[,3])*powerTables[[set]]\\$data[,2],\n\t         xlab = \"Soft Threshold (power)\", ylab = colNames[col],type = \"n\", ylim = ylim[, col],\n\t         main = colNames[col]);\n\t    addGrid();\n\t  }\n\t  if (col==1)\n\t  {\n\t    text(powerTables[[set]]\\$data[,1], -sign(powerTables[[set]]\\$data[,3])*powerTables[[set]]\\$data[,2],\n\t         labels = powers, cex = cex1, col = colors[set]);\n\t  } else\n\t    text(powerTables[[set]]\\$data[,1], powerTables[[set]]\\$data[,plotCols[col]],\n\t         labels = powers, cex = cex1, col = colors[set]);\n\t  # if (col==1)\n\t  # {\n\t  #   legend(\"bottomright\", legend = setLabels, col = colors, pch = 20) ;\n\t  # } else\n\t  #   legend(\"topright\", legend = setLabels, col = colors, pch = 20) ;\n\t}\n\tdev.off();\n\n\tprint(\"2 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 3\n\t#\n\t#=====================================================================================\n\n\t# Form multi-set expression data: columns starting from 9 contain actual expression data.\n\tmultiExpr = vector(mode = \"list\", length = nSets)\n\tmultiExpr[[1]] = list(data = datExpr);\n\tnames(multiExpr[[1]]\\$data) = colnames(datExpr);\n\trownames(multiExpr[[1]]\\$data) = rownames(datExpr);\n\n\n\t# Check that the data has the correct format for many functions operating on multiple sets:\n\texprSize = checkSets(multiExpr)\n\n\tfor (i in 1:ncol(multiExpr[[1]]\\$data)) {\n\t  multiExpr[[1]]\\$data[,i] <- as.numeric(as.character(multiExpr[[1]]\\$data[,i]))\n\t  }\n\n\tsoftTreshold <- 8\n\n\n\tnet <- blockwiseConsensusModules(\n\t        multiExpr, power = softTreshold , minModuleSize = 20, deepSplit = 2,\n\t        pamRespectsDendro = FALSE, \n\t        mergeCutHeight = 0.25, numericLabels = TRUE,\n\t        minKMEtoStay = 0,\n\t        saveTOMs = TRUE, verbose = 5)\n\n\tprint(\"3 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 4\n\t#\n\t#=====================================================================================\n\n\tconsMEs = net\\$multiMEs;\n\tmoduleLabels = net\\$colors;\n\t# Convert the numeric labels to color labels\n\tmoduleColors = labels2colors(moduleLabels)\n\tconsTree = net\\$dendrograms[[1]]; \n\t# saving modules and genes in a table\n\tanno = read.csv(file = \"../../GO/Mouse2GO.csv\", sep = \",\");\n\tanno = anno[,c(1:2)]\n\t# Save annotation and data expression files to .csv file\n\twrite.csv(anno, file = \"Info/anno.csv\", row.names = FALSE)\n\twrite.csv(data\\$X, file = \"Info/datExpr.csv\", row.names = FALSE)\n\n\tt <- colnames(multiExpr[[1]]\\$data)\n\tt <- as.matrix(t)\n\thead(t)\n\tcolnames(t) <- \"GENE\"\n\n\t# Right merge of annotation and data datasets\n\t#genesAnno <- merge(x = anno, y = t, by= \"GENE\" ,all.y = TRUE). # THIS ONE TRIGGERS AN ERROR (OT)\n\tgenesAnno <- merge(x = anno, y = t, by.x= 'gene_id', by.y = 'GENE'  ,all.y = TRUE)\n\n\tgenesAnno <- genesAnno[,c(1:2)]\n\tcolnames(genesAnno) <- c(\"GENES\", \"Annotation\")\n\n\tlibrary(dplyr)\n\n\ttest <- genesAnno %>% group_by(GENES) %>% summarise(Annotations = paste(Annotation, collapse = \", \"))\n\tcolnames(test)\n\n\t# Write text file with genes and corresponding modules and annotations\n\tmod <- data.frame(\"Gene\" = t, \"Modules\" = labels2colors(moduleLabels), \"Annotation\" = test\\$Annotations)\n\tmod <- mod[order(mod\\$Modules),]\n\twrite.table(mod, file = \"Info/ModuleMembers.txt\", row.names = F, sep = \"\\t\", quote = F)\n\n\tsave(consMEs, moduleLabels, moduleColors, consTree, file = \"02-networkConstruction-auto.RData\")\n\n\tprint(\"4 done\")\n\n\t############################################################################################################################################################################################\n\t# 3 - Relating modules to external clinical traits and identifying important genes\n\t############################################################################################################################################################################################\n\n\tprint(\"start part 3\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 1\n\t#\n\t#=====================================================================================\n\n\t# Display the current working directory\n\t#getwd();\n\t# If necessary, change the path below to the directory where the data files are stored. \n\t# \".\" means current directory. On Windows use a forward slash / instead of the usual .\n\tworkingDir = \".\";\n\tsetwd(workingDir); \n\t# Load the WGCNA package\n\tlibrary(WGCNA)\n\t# The following setting is important, do not omit.\n\toptions(stringsAsFactors = FALSE);\n\t# Load the expression and trait data saved in the first part\n\tlnames = load(file = \"01-dataInput.RData\");\n\t#The variable lnames contains the names of loaded variables.\n\tlnames\n\t# Load network data saved in the second part.\n\tlnames = load(file = \"02-networkConstruction-auto.RData\");\n\tlnames\n\n\tprint(\"3.1 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 2\n\t#\n\t#=====================================================================================\n\n\t# Define numbers of genes and samples\n\tnGenes = ncol(datExpr);\n\tnSamples = nrow(datExpr);\n\t# Recalculate MEs with color labels\n\tMEs0 = moduleEigengenes(datExpr, moduleColors)\\$eigengenes\n\tMEs = orderMEs(MEs0)\n\tmoduleTraitCor = cor(MEs, datTraits, use = \"p\");\n\tmoduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);\n\n\twrite.table(moduleTraitCor, file = \"Info/metabolites_transcriptomics_corr_matrix.txt\", row.names = T, sep = \"\\t\", quote = F)\n\n\tprint(\"3.2 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 3\n\t#\n\t#=====================================================================================\n\n\tsizeGrWindow(10,6)\n\t# Will display correlations and their p-values\n\ttextMatrix =  paste(signif(moduleTraitCor, 2), \"\\n(\",\n\t                           signif(moduleTraitPvalue, 1), \")\", sep = \"\");\n\tdim(textMatrix) = dim(moduleTraitCor)\n\t# Display the correlation values within a heatmap plot\n\tpdf(file = \"Figures/Heatmap_metabolites_transcriptomics_corr_matrix.pdf\", wi = 10, he = 6)\n\tpar(mar = c(3, 6, 7, 3));\n\tlabeledHeatmap(Matrix = moduleTraitCor,\n\t               xLabels = colnames(moduleTraitCor),\n\t               xLabelsPosition = \"top\",\n\t               xLabelsAngle = -90,\n\t               yLabels = names(MEs),\n\t               ySymbols = names(MEs),\n\t               colorLabels = FALSE,\n\t               colors = greenWhiteRed(50),\n\t               setStdMargins = FALSE,\n\t               cex.text = 0.5,\n\t               cex.lab.x = 0.45,\n\t               cex.lab.y = 0.3,\n\t               zlim = c(-1,1))\n\ttitle(\"Module-trait relationships\", line = 5)\n\tdev.off()\n\n\tprint(\"3.3 done\")\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 4\n\t#\n\t#=====================================================================================\n\n\t# \n\tmetabo = list()\n\tfor (i in colnames(moduleTraitPvalue)) {\n\t  # Define variable meta containing the metabolite columns of datTrait\n\t  meta <- data.frame(datTraits[,i]);\n\t  meta\\$i <- i\n\t  metabo[[i]] <- meta\n\t}\n\n\tmetabol = do.call(cbind, metabo)\n\tmetabol <- metabol[c(T,F)]\n\tcolnames(metabol) = gsub(\".datTraits...i.\", \"\", colnames(metabol))\n\t  \n\t# Names (colors) of the modules\n\tmodNames = substring(names(MEs), 3)\n\tgeneModuleMembership = as.data.frame(cor(datExpr, MEs, use = \"p\"));\n\tMMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples), append = T);\n\n\tnames(geneModuleMembership) = paste(\"MM\", modNames, sep=\"\");\n\tnames(MMPvalue) = paste(\"p.MM\", modNames, sep=\"\");\n\t  \n\tgeneTraitSignificance = as.data.frame(cor(datExpr, metabol, use = \"p\"));\n\tGSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));\n\t  \n\tnames(geneTraitSignificance) = paste(\"GS.\", names(metabol), sep=\"\");\n\tnames(GSPvalue) = paste(\"p.GS.\", names(metabol), sep=\"\");\n\n\tprint(\"3.4 done\")\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 5 \n\t#\n\t#=====================================================================================\n\n\t# Calculate the module membership values (aka. module eigengene based connectivity kME):\n\tdatKME <- signedKME(datExpr, MEs)  # equals geneModuleMembership\n\tcolnames(datKME) <- sub(\"kME\", \"MM.\", colnames(datKME))\n\n\tcolorOfColumn <- substring(names(datKME),4)\n\n\tmetabolites <- colnames(moduleTraitPvalue)\n\tfor (metabolite in metabolites) {\n\t  cat(paste(\"\\nmetabolite:\", metabolite, \"\\n\"))\n\t  pdf(paste0(\"ModuleMembership_vs_GeneSignificance/\", metabolite, \"_ModuleMembershipVsgeneSig.pdf\"))\n\t  par(mar=c(6, 8, 4, 4) + 0.1)\n\t  modNames = substring(names(MEs), 3)\n\t  for (module in modNames) {\n\t    column <- match(module,colorOfColumn)\n\t    moduleGenes <- moduleColors == module;\n\t    GS = paste(\"GS.\", metabolite, sep = \"\")\n\t    verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),\n\t                       abs(geneTraitSignificance[moduleGenes, GS]),\n\t                       xlab = paste(\"Module membership in\", module, \"module\"),\n\t                       ylab = paste(\"Gene significance for\", metabolite),\n\t                       xlim = c(0,1),\n\t                       ylim = c(0,1),\n\t                       main = paste(\"Module membership vs. gene significance\\n\"),\n\t                       cex.main = 1.3,\n\t                       cex.lab = 1.1,\n\t                       cex.axis = 1,\n\t                       pch = 21, \n\t                       col = \"dark gray\", \n\t                       bg = module)\n\t  }\n\t  \n\t  dev.off()\n\t} # end of loop\n\n\tprint(\"3.5 done\")\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 6\n\t#\n\t#=====================================================================================\n\n\n\t# Define top genes for every metabolite in every module \n\ttopGene <- list()\n\ttopGene_ <- list()\n\tfor(metabolite in metabolites) {\n\t  for(module in modNames) {\n\t    GS = paste(\"GS.\", metabolite, sep = \"\")\n\t    MM = paste(\"MM\", module, sep = \"\")\n\t    topGenes = abs(geneModuleMembership[,MM]) > 0.8 & abs(geneTraitSignificance[,GS]) > 0.8\n\t    topGene[[module]] <- topGenes\n\t  }\n\t  topGene_[[metabolite]] <- topGene\n\t} # end of loop\n\n\t# Link with gene names\n\ttopGene2name <- list()\n\ttopGene2name_ <- list()\n\tfor(metabolite in metabolites) {\n\t  for(module in modNames) {\n\t    topGenes2names <- dimnames(datExpr)[[2]][topGene_[[metabolite]][[module]]]\n\t    topGene2name[[module]] <- topGenes2names\n\t  }\n\t  topGene2name_[[metabolite]] <- topGene2name\n\t} # end of loop\n\n\t# Filter empty list \n\tfilterGene1_ <- list()\n\tfor(metabolite in names(topGene2name_)) {\n\t  filter = topGene2name_[[metabolite]][lapply(topGene2name_[[metabolite]],length)>0]\n\t  filterGene1_[[metabolite]] <- filter\n\t} # end of loop\n\n\n\t# Filter empty list \n\tfilterGene_ <- list()\n\tfor (items in filterGene1_){\n\t  filter2 = filterGene1_[lapply(filterGene1_,length)>0]\n\t  filterGene_ <- filter2\n\t}\n\n\tprint(\"3.6 done\")\n\n\n\n\t#=====================================================================================\n\t#\n\t#  Code chunk 7\n\t#\n\t#=====================================================================================\n\n\t# Write output to files\n\tmetabolites2 <-names(filterGene_)\n\tfor(metabolite in metabolites2) {\n\t  modules <-names(filterGene_[[metabolite]])\n\t  GTS <- paste(\"GS.\", metabolite, sep = \"\")\n\t  \n\t  for(module in modules) {\n\t    cat(paste(\"\\nCreating output for top genes in\", module, \"for\", metabolite, \"\\n\"))\n\t    genes <- filterGene_[[metabolite]][[module]]\n\t    GMM = paste(\"MM\", module, sep = \"\")\n\t    # Create the starting data frame\n\t    infoGenes = list(genes = genes,\n\t                           moduleColor = moduleColors[topGene_[[metabolite]][[module]]],\n\t                           annotation = test\\$Annotations[topGene_[[metabolite]][[module]]],\n\t                           geneTraitSignificance = geneTraitSignificance[filterGene_[[metabolite]][[module]], GTS],\n\t                           geneModuleMembership = geneModuleMembership[filterGene_ [[metabolite]][[module]], GMM])\n\t    \n\n\t    # Order the genes in the infoTopGenes variable first by module color, then by geneTraitSignificance\n\t    #geneOrder <- order(infoGenes\\$moduleColor, -abs(infoGenes[,4]))\n\t    #infoGenes = infoGenes[geneOrder, ]\n\t    \n\t    write.csv(infoGenes, file = paste0(\"GeneInfo/\", module, \"_\", metabolite, \"_GeneInfo.csv\"), row.names = FALSE)\n\t  }\n\t} # end of loop\n\n\tprint(\"3.7 done\")\n\n\n\n\t\"\"\"",
        "nb_lignes_script": 545,
        "language_script": "Rscript",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "files"
        ],
        "nb_inputs": 1,
        "outputs": [
            "test"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "doSomething": {
        "name_process": "doSomething",
        "string_process": "\nprocess doSomething{\n    tag \"$x\"\n    \n    input:\n\tval x from nextChannel\n\n    output:\n\tset val(x), file(outputFile) into outputChannel\n    \n    script:\n\t\"\"\"\n        echo \"$params.tweak.a $params.tweak.b $params.tweak.c   : $x\"> outputFile\n        \"\"\"\n}",
        "nb_lignes_process": 13,
        "string_script": "\t\"\"\"\n        echo \"$params.tweak.a $params.tweak.b $params.tweak.c   : $x\"> outputFile\n        \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "nextChannel"
        ],
        "nb_inputs": 1,
        "outputs": [
            "outputChannel"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [
            "tag \"$x\""
        ],
        "when": "",
        "stub": ""
    },
    "leftOrRight": {
        "name_process": "leftOrRight",
        "string_process": "\nprocess leftOrRight{\n    input:\n\tval resultList from allDone\n\n    output:\n\tval answer into goOn\n\n    exec:\n\tprint resultList\n        println \"\"\n        print \"What now ([L]eft/[R]ight/[Q]uit)?   \"\n        answer = new InputStreamReader(System.in).readLine()\n}",
        "nb_lignes_process": 12,
        "string_script": "\tprint resultList\n        println \"\"\n        print \"What now ([L]eft/[R]ight/[Q]uit)?   \"\n        answer = new InputStreamReader(System.in).readLine()",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [
            "GeneAnswers"
        ],
        "tools_url": [
            "https://bio.tools/geneanswers"
        ],
        "tools_dico": [
            {
                "name": "GeneAnswers",
                "uri": "https://bio.tools/geneanswers",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3053",
                            "term": "Genetics"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Gene expression profiling"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression data analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Functional profiling"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Gene expression profile construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Feature expression analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Gene transcription profiling"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Gene expression quantification"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0314",
                                    "term": "Gene expression profile generation"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Provides an integrated tool for biological or medical interpretation of the given one or more groups of genes by means of statistical test.",
                "homepage": "http://bioconductor.org/packages/release/bioc/html/GeneAnswers.html"
            }
        ],
        "inputs": [
            "allDone"
        ],
        "nb_inputs": 1,
        "outputs": [
            "goOn"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "left": {
        "name_process": "left",
        "string_process": "\nprocess left{\n    input:\n\tval answer from goOnLeft\n\n    when:\n\tanswer=='L'\n\n    exec:\n\tprint \"Run process LEFT\"\n}",
        "nb_lignes_process": 9,
        "string_script": "\tprint \"Run process LEFT\"",
        "nb_lignes_script": 0,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "goOnLeft"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "answer=='L'",
        "stub": ""
    },
    "right": {
        "name_process": "right",
        "string_process": "\nprocess right{\n    input:\n\tval answer from goOnRight\n\n    when:\n\tanswer=='R'\n\n    exec:\n\tprint \"Run process RIGHT\"\n}",
        "nb_lignes_process": 9,
        "string_script": "\tprint \"Run process RIGHT\"",
        "nb_lignes_script": 0,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "goOnRight"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "answer=='R'",
        "stub": ""
    },
    "stop": {
        "name_process": "stop",
        "string_process": "\nprocess stop{\n    input:\n\tval answer from stopPipeline\n\n    when:\n\tanswer=='Q'\n\n    exec:\n\tprint \"Bye!\"\n}",
        "nb_lignes_process": 9,
        "string_script": "\tprint \"Bye!\"",
        "nb_lignes_script": 0,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "stopPipeline"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [],
        "when": "answer=='Q'",
        "stub": ""
    },
    "init": {
        "name_process": "init",
        "string_process": "\nprocess init{\n    tag \"$x\"\n\n    input:\n\tval x from inputChannel\n\n    output:\n\tval y into nextChannel\n\n    exec:\n\ty = 2*x\n}",
        "nb_lignes_process": 11,
        "string_script": "\ty = 2*x",
        "nb_lignes_script": 0,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "inputChannel"
        ],
        "nb_inputs": 1,
        "outputs": [
            "nextChannel"
        ],
        "nb_outputs": 1,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [
            "tag \"$x\""
        ],
        "when": "",
        "stub": ""
    },
    "nextStep": {
        "name_process": "nextStep",
        "string_process": "\nprocess nextStep{\n    tag \"$x\"\n    \n    input:\n\tset val(x), file(myFile) from outputChannel\n\n    script:\n\t\"\"\"\n        \"\"\"\n}",
        "nb_lignes_process": 9,
        "string_script": "\t\"\"\"\n        \"\"\"",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "outputChannel"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "vibbits__NextFlow_pipelines",
        "directive": [
            "tag \"$x\""
        ],
        "when": "",
        "stub": ""
    }
}