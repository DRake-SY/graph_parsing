{
    "sortmerna_pe": {
        "name_process": "sortmerna_pe",
        "string_process": "process sortmerna_pe {\n\n  container \"bschiffthaler/sortmerna:\" + params.sortmerna_version\n  publishDir \"analysis/sortmerna\", pattern: \"*.{fastq,fq}.gz\"\n  publishDir \"report/logs/\", pattern: \"*sortmerna.log\"\n  cpus params.sortmerna_cpus\n\n  input:\n    tuple path(read1), path(read2), val(name)\n    path index\n    val dbs\n    val args\n    val meta\n\n  output:\n    tuple path(\"${name}_sortmerna_fwd.{fastq,fq}.gz\"), path(\"${name}_sortmerna_rev.{fastq,fq}.gz\"), val(name), emit: data_clean\n    tuple path(\"${name}_rrna_fwd.{fastq,fq}.gz\"), path(\"${name}_rrna_rev.{fastq,fq}.gz\"), val(name), emit: data_rrna\n    path \"${name}_sortmerna.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _dbs = dbs.join(\" --ref \")\n    _args = args.join(\" \")\n    \"\"\"\n    sortmerna --ref ${_dbs} --reads ${read1} --reads ${read2} --idx-dir ${index} \\\n      --workdir ${name}_sortmerna --threads ${params.sortmerna_cpus} \\\n      --fastx --aligned ${name}_rrna --other ${name}_sortmerna --paired_in \\\n      --out2\n    find . -mindepth 1 -maxdepth 1 -name \"*.f*q\" -exec gzip {} \\\\; || true\n    cp ${name}_rrna.log ${name}_sortmerna.log\n    \"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "    _dbs = dbs.join(\" --ref \")\n    _args = args.join(\" \")\n    \"\"\"\n    sortmerna --ref ${_dbs} --reads ${read1} --reads ${read2} --idx-dir ${index} \\\n      --workdir ${name}_sortmerna --threads ${params.sortmerna_cpus} \\\n      --fastx --aligned ${name}_rrna --other ${name}_sortmerna --paired_in \\\n      --out2\n    find . -mindepth 1 -maxdepth 1 -name \"*.f*q\" -exec gzip {} \\\\; || true\n    cp ${name}_rrna.log ${name}_sortmerna.log\n    \"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [
            "SortMeRna"
        ],
        "tools_url": [
            "https://bio.tools/sortmerna"
        ],
        "tools_dico": [
            {
                "name": "SortMeRna",
                "uri": "https://bio.tools/sortmerna",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3308",
                            "term": "Transcriptomics"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2451",
                                    "term": "Sequence comparison"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0346",
                                    "term": "Sequence similarity search"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0258",
                                    "term": "Sequence alignment analysis"
                                }
                            ],
                            []
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Sequence analysis tool for filtering, mapping and OTU-picking NGS reads.",
                "homepage": "http://bioinfo.lifl.fr/RNA/sortmerna/"
            }
        ],
        "inputs": [
            "name",
            "read1",
            "read2",
            "index",
            "dbs",
            "args",
            "meta"
        ],
        "nb_inputs": 7,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/sortmerna:\" + params.sortmerna_version",
            "publishDir \"analysis/sortmerna\", pattern: \"*.{fastq,fq}.gz\"",
            "publishDir \"report/logs/\", pattern: \"*sortmerna.log\"",
            "cpus params.sortmerna_cpus"
        ],
        "when": "",
        "stub": ""
    },
    "salmon_pe": {
        "name_process": "salmon_pe",
        "string_process": "process salmon_pe {\n\n  container \"bschiffthaler/salmon:\" + params.salmon_version\n  publishDir \"analysis/${prefix}\", pattern: \"salmon_*\"\n  publishDir \"report/logs/${prefix}\", pattern: \"*salmon_logs\"\n  cpus params.salmon_cpus\n\n  input:\n    val prefix\n    tuple path(read1), path(read2), val(name)\n    path index\n    val libtype\n    val args\n    val meta\n\n  output:\n    tuple path(\"salmon_${name}\"), val(name), emit: data\n    path \"${name}_salmon_logs\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    salmon quant -l${libtype} -i ${index} -1 ${read1} -2 ${read2} \\\n      -p ${params.salmon_cpus} -o salmon_${name} \\\n      ${_args}\n    mkdir ${name}_salmon_logs\n    cp -r salmon_${name}/logs ${name}_salmon_logs/.\n    cp -r salmon_${name}/libParams ${name}_salmon_logs/.\n    cp -r salmon_${name}/aux_info ${name}_salmon_logs/.\n    \"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    salmon quant -l${libtype} -i ${index} -1 ${read1} -2 ${read2} \\\n      -p ${params.salmon_cpus} -o salmon_${name} \\\n      ${_args}\n    mkdir ${name}_salmon_logs\n    cp -r salmon_${name}/logs ${name}_salmon_logs/.\n    cp -r salmon_${name}/libParams ${name}_salmon_logs/.\n    cp -r salmon_${name}/aux_info ${name}_salmon_logs/.\n    \"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [
            "Salmon"
        ],
        "tools_url": [
            "https://bio.tools/salmon"
        ],
        "tools_dico": [
            {
                "name": "Salmon",
                "uri": "https://bio.tools/salmon",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3308",
                            "term": "Transcriptomics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0203",
                            "term": "Gene expression"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Transcriptome profiling"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small RNA sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA-Seq analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small RNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Whole transcriptome shotgun sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "WTSS"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0203",
                            "term": "Expression"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3800",
                                    "term": "RNA-Seq quantification"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0236",
                                    "term": "Sequence composition calculation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression data analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3800",
                                    "term": "RNA-Seq quantitation"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_3496",
                                "term": "RNA sequence (raw)"
                            },
                            {
                                "uri": "http://edamontology.org/data_2093",
                                "term": "Data reference"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_2048",
                                "term": "Report"
                            }
                        ]
                    }
                ],
                "description": "A tool for transcript expression quantification from RNA-seq data",
                "homepage": "https://github.com/COMBINE-lab/salmon"
            }
        ],
        "inputs": [
            "prefix",
            "name",
            "read1",
            "read2",
            "index",
            "libtype",
            "args",
            "meta"
        ],
        "nb_inputs": 8,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/salmon:\" + params.salmon_version",
            "publishDir \"analysis/${prefix}\", pattern: \"salmon_*\"",
            "publishDir \"report/logs/${prefix}\", pattern: \"*salmon_logs\"",
            "cpus params.salmon_cpus"
        ],
        "when": "",
        "stub": ""
    },
    "salmon_index_with_decoy": {
        "name_process": "salmon_index_with_decoy",
        "string_process": "\nprocess salmon_index_with_decoy {\n\n  container \"bschiffthaler/salmon:\" + params.salmon_version\n  publishDir \"analysis/salmon\", pattern: \"salmon_index\"\n  publishDir \"report/logs/\", pattern: \"salmon_index.log\"\n  cpus params.salmon_index_cpus\n\n  input:\n    path(transcriptome)\n    path(genome)\n    val args\n\n  output:\n    path salmon_index, emit: data\n    path \"salmon_index.log\", emit: log\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    zcat ${genome} | grep -E '^>' | cut -d ' ' -f 1 > decoys.txt\n    sed -i.bak -e 's/>//g' decoys.txt\n    cat ${transcriptome} ${genome} > gentrome.fa.gz\n    salmon index -t gentrome.fa.gz -d decoys.txt \\\n      -p ${params.salmon_index_cpus} -i salmon_index ${_args} \\\n      2>&1 | tee salmon_index.log\n    \"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    zcat ${genome} | grep -E '^>' | cut -d ' ' -f 1 > decoys.txt\n    sed -i.bak -e 's/>//g' decoys.txt\n    cat ${transcriptome} ${genome} > gentrome.fa.gz\n    salmon index -t gentrome.fa.gz -d decoys.txt \\\n      -p ${params.salmon_index_cpus} -i salmon_index ${_args} \\\n      2>&1 | tee salmon_index.log\n    \"\"\"",
        "nb_lignes_script": 8,
        "language_script": "bash",
        "tools": [
            "Salmon"
        ],
        "tools_url": [
            "https://bio.tools/salmon"
        ],
        "tools_dico": [
            {
                "name": "Salmon",
                "uri": "https://bio.tools/salmon",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3308",
                            "term": "Transcriptomics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0203",
                            "term": "Gene expression"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Transcriptome profiling"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small RNA sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA-Seq analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small RNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Small-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "Whole transcriptome shotgun sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "RNA sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3170",
                            "term": "WTSS"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0203",
                            "term": "Expression"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3800",
                                    "term": "RNA-Seq quantification"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0236",
                                    "term": "Sequence composition calculation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2495",
                                    "term": "Expression data analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3800",
                                    "term": "RNA-Seq quantitation"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_3496",
                                "term": "RNA sequence (raw)"
                            },
                            {
                                "uri": "http://edamontology.org/data_2093",
                                "term": "Data reference"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_2048",
                                "term": "Report"
                            }
                        ]
                    }
                ],
                "description": "A tool for transcript expression quantification from RNA-seq data",
                "homepage": "https://github.com/COMBINE-lab/salmon"
            }
        ],
        "inputs": [
            "transcriptome",
            "genome",
            "args"
        ],
        "nb_inputs": 3,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/salmon:\" + params.salmon_version",
            "publishDir \"analysis/salmon\", pattern: \"salmon_index\"",
            "publishDir \"report/logs/\", pattern: \"salmon_index.log\"",
            "cpus params.salmon_index_cpus"
        ],
        "when": "",
        "stub": ""
    },
    "process_radtags_pe": {
        "name_process": "process_radtags_pe",
        "string_process": "process process_radtags_pe {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n  cpus 1\n\n  input:\n    tuple path(read1), path(read2), val(name)\n    val args\n    val meta\n\n  output:\n    tuple path(\"${name}_trimmed{.1,.rem.1,.2,.rem.2}.fq.gz\"), val(name), emit: data\n    path \"${name}_process_radtags.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n\n    \"\"\"\n    process_radtags -1 ${read1} -2 ${read2} \\\n      -o . \\\n      --paired \\\n      ${_args} &> ${name}_process_radtags.log\n    mv ${name}_trimmed_1.1.fq.gz ${name}_trimmed.1.fq.gz\n    mv ${name}_trimmed_1.rem.1.fq.gz ${name}_trimmed.rem.1.fq.gz\n    mv ${name}_trimmed_2.2.fq.gz ${name}_trimmed.2.fq.gz\n    mv ${name}_trimmed_2.rem.2.fq.gz ${name}_trimmed.rem.2.fq.gz\n    \"\"\"\n}",
        "nb_lignes_process": 30,
        "string_script": "    _args = args.join(\" \")\n\n    \"\"\"\n    process_radtags -1 ${read1} -2 ${read2} \\\n      -o . \\\n      --paired \\\n      ${_args} &> ${name}_process_radtags.log\n    mv ${name}_trimmed_1.1.fq.gz ${name}_trimmed.1.fq.gz\n    mv ${name}_trimmed_1.rem.1.fq.gz ${name}_trimmed.rem.1.fq.gz\n    mv ${name}_trimmed_2.2.fq.gz ${name}_trimmed.2.fq.gz\n    mv ${name}_trimmed_2.rem.2.fq.gz ${name}_trimmed.rem.2.fq.gz\n    \"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "name",
            "read1",
            "read2",
            "args",
            "meta"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\"",
            "cpus 1"
        ],
        "when": "",
        "stub": ""
    },
    "ustacks": {
        "name_process": "ustacks",
        "string_process": "\nprocess ustacks {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.ustacks_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n\n  input:\n    tuple path(reads), val(name)\n    val args\n    val meta\n\n  output:\n    tuple path(\"_tmpout/*\"), val(name), emit: data\n    path \"${name}_ustacks.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    _id = meta.NumId\n    \"\"\"\n    mkdir _tmpout\n    ustacks -f ${reads[0]} \\\n      -i ${_id} \\\n      -o _tmpout \\\n      -p ${params.ustacks_cpus} \\\n      ${_args} &> ${name}_ustacks.log\n    mv _tmpout/${name}_trimmed.1.alleles.tsv.gz _tmpout/${name}_trimmed.alleles.tsv.gz\n    mv _tmpout/${name}_trimmed.1.snps.tsv.gz _tmpout/${name}_trimmed.snps.tsv.gz\n    mv _tmpout/${name}_trimmed.1.tags.tsv.gz _tmpout/${name}_trimmed.tags.tsv.gz \n    \"\"\"\n}",
        "nb_lignes_process": 32,
        "string_script": "    _args = args.join(\" \")\n    _id = meta.NumId\n    \"\"\"\n    mkdir _tmpout\n    ustacks -f ${reads[0]} \\\n      -i ${_id} \\\n      -o _tmpout \\\n      -p ${params.ustacks_cpus} \\\n      ${_args} &> ${name}_ustacks.log\n    mv _tmpout/${name}_trimmed.1.alleles.tsv.gz _tmpout/${name}_trimmed.alleles.tsv.gz\n    mv _tmpout/${name}_trimmed.1.snps.tsv.gz _tmpout/${name}_trimmed.snps.tsv.gz\n    mv _tmpout/${name}_trimmed.1.tags.tsv.gz _tmpout/${name}_trimmed.tags.tsv.gz \n    \"\"\"",
        "nb_lignes_script": 12,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "name",
            "reads",
            "args",
            "meta"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.ustacks_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\""
        ],
        "when": "",
        "stub": ""
    },
    "cstacks": {
        "name_process": "cstacks",
        "string_process": "\nprocess cstacks {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.cstacks_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n\n  input:\n    path stacks\n    path popmap\n    val args\n    val meta\n\n  output:\n    path \"*.{gz,tsv}\", emit: data\n    path \"cstacks.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    cstacks -P . \\\n      -p ${params.cstacks_cpus} \\\n      -M ${popmap} \\\n      ${_args} &> cstacks.log\n    \"\"\"\n}",
        "nb_lignes_process": 27,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    cstacks -P . \\\n      -p ${params.cstacks_cpus} \\\n      -M ${popmap} \\\n      ${_args} &> cstacks.log\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "stacks",
            "popmap",
            "args",
            "meta"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.cstacks_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\""
        ],
        "when": "",
        "stub": ""
    },
    "sstacks": {
        "name_process": "sstacks",
        "string_process": "\nprocess sstacks {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.sstacks_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n\n  input:\n    path catalog\n    path stacks\n    path popmap\n    val args\n    val meta\n\n  output:\n    path \"*.{gz,tsv}\", emit: data\n    path \"sstacks.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    sstacks -P . \\\n      -p ${params.sstacks_cpus} \\\n      -M ${popmap} \\\n      ${_args} &> sstacks.log\n    \"\"\"\n}",
        "nb_lignes_process": 28,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    sstacks -P . \\\n      -p ${params.sstacks_cpus} \\\n      -M ${popmap} \\\n      ${_args} &> sstacks.log\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "catalog",
            "stacks",
            "popmap",
            "args",
            "meta"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.sstacks_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\""
        ],
        "when": "",
        "stub": ""
    },
    "tsv2bam": {
        "name_process": "tsv2bam",
        "string_process": "\nprocess tsv2bam {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.tsv2bam_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n\n  input:\n    path catalog\n    path stacks\n    path maches\n    path pe_reads\n    path popmap\n    val args\n    val meta\n\n  output:\n    path \"*.bam\", emit: data\n    path \"tsv2bam.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    tsv2bam -P . \\\n      -t ${params.tsv2bam_cpus} \\\n      -M ${popmap} \\\n      --pe-reads-dir . \\\n      ${_args} &> tsv2bam.log\n    \"\"\"\n}",
        "nb_lignes_process": 31,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    tsv2bam -P . \\\n      -t ${params.tsv2bam_cpus} \\\n      -M ${popmap} \\\n      --pe-reads-dir . \\\n      ${_args} &> tsv2bam.log\n    \"\"\"",
        "nb_lignes_script": 7,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "catalog",
            "stacks",
            "maches",
            "pe_reads",
            "popmap",
            "args",
            "meta"
        ],
        "nb_inputs": 7,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.tsv2bam_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\""
        ],
        "when": "",
        "stub": ""
    },
    "gstacks": {
        "name_process": "gstacks",
        "string_process": "\nprocess gstacks {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.gstacks_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n  publishDir \"report/logs/\", pattern: \"*.distribs\"\n\n  input:\n    path bam_files\n    path popmap\n    val args\n    val meta\n\n  output:\n    path \"*.{gz,calls}\", emit: data\n    path \"gstacks.{log,log.distribs}\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    gstacks -P . \\\n      -M ${popmap} \\\n      -t ${params.gstacks_cpus} \\\n      ${_args} &> gstacks.log\n    \"\"\"\n}",
        "nb_lignes_process": 28,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    gstacks -P . \\\n      -M ${popmap} \\\n      -t ${params.gstacks_cpus} \\\n      ${_args} &> gstacks.log\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "bam_files",
            "popmap",
            "args",
            "meta"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.gstacks_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\"",
            "publishDir \"report/logs/\", pattern: \"*.distribs\""
        ],
        "when": "",
        "stub": ""
    },
    "populations": {
        "name_process": "populations",
        "string_process": "\nprocess populations {\n\n  container \"bschiffthaler/stacks:\" + params.stacks_version\n  executor params.executor\n  cpus params.populations_cpus\n  publishDir \"analysis/stacks\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n  publishDir \"report/logs/\", pattern: \"*.distribs\"\n  publishDir \"report/logs/\", pattern: \"*sumstats_summary.tsv\"\n\n  input:\n    path catalog\n    path stacks\n    path maches\n    path pe_reads\n    path bam_files\n    path calls\n    path popmap\n    val args\n    val meta\n\n  output:\n    path \"*.{tsv,fa,gz,vcf,gtf}\", emit: data\n    tuple path(\"populations.{log,log.distribs}\"), path(\"*.sumstats_summary.tsv\"), emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    populations -P . \\\n      -M ${popmap} \\\n      -t ${params.populations_cpus} \\\n      --vcf \\\n      --fasta-loci \\\n      --fasta-samples \\\n      --verbose \\\n      ${_args} &> populations.log\n    \"\"\"\n}",
        "nb_lignes_process": 38,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    populations -P . \\\n      -M ${popmap} \\\n      -t ${params.populations_cpus} \\\n      --vcf \\\n      --fasta-loci \\\n      --fasta-samples \\\n      --verbose \\\n      ${_args} &> populations.log\n    \"\"\"",
        "nb_lignes_script": 10,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "catalog",
            "stacks",
            "maches",
            "pe_reads",
            "bam_files",
            "calls",
            "popmap",
            "args",
            "meta"
        ],
        "nb_inputs": 9,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/stacks:\" + params.stacks_version",
            "executor params.executor",
            "cpus params.populations_cpus",
            "publishDir \"analysis/stacks\"",
            "publishDir \"report/logs/\", pattern: \"*.log\"",
            "publishDir \"report/logs/\", pattern: \"*.distribs\"",
            "publishDir \"report/logs/\", pattern: \"*sumstats_summary.tsv\""
        ],
        "when": "",
        "stub": ""
    },
    "fastq_screen_pe": {
        "name_process": "fastq_screen_pe",
        "string_process": "process fastq_screen_pe {\n\n  container \"bschiffthaler/fastq_screen:\" + params.fastq_screen_version\n  publishDir \"analysis/fastq_screen\", pattern: \"*_screen.{png,html,txt}\"\n  publishDir \"report/logs/\", pattern: \"*_screen.log\"\n  cpus params.fastq_screen_cpus\n\n  input:\n    tuple path(read1), path(read2), val(name)\n    path index\n    val args\n    val meta\n\n  output:\n    path \"*_screen.{png,html,txt}\", emit: data\n    path \"*_screen.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    fastq_screen --aligner bowtie2 \\\n      --conf ${index}/fastq_screen.conf \\\n      --threads ${params.fastq_screen_cpus} ${read1} ${read2} \\\n      ${_args} \\\n      2>&1 > ${name}_screen.log\n    \"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    fastq_screen --aligner bowtie2 \\\n      --conf ${index}/fastq_screen.conf \\\n      --threads ${params.fastq_screen_cpus} ${read1} ${read2} \\\n      ${_args} \\\n      2>&1 > ${name}_screen.log\n    \"\"\"",
        "nb_lignes_script": 7,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "name",
            "read1",
            "read2",
            "index",
            "args",
            "meta"
        ],
        "nb_inputs": 6,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/fastq_screen:\" + params.fastq_screen_version",
            "publishDir \"analysis/fastq_screen\", pattern: \"*_screen.{png,html,txt}\"",
            "publishDir \"report/logs/\", pattern: \"*_screen.log\"",
            "cpus params.fastq_screen_cpus"
        ],
        "when": "",
        "stub": ""
    },
    "multiqc": {
        "name_process": "multiqc",
        "string_process": "process multiqc {\n\n  container \"bschiffthaler/multiqc:\" + params.multiqc_version\n  publishDir \"report/multiqc\"\n  cpus 1\n\n  input:\n    path location\n    val args\n    val meta\n\n  output:\n    path \"multiqc_*\", emit: data\n    path \"multiqc.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _args = args.join(\" \")\n    \"\"\"\n    multiqc . \\\n      ${_args} &> multiqc.log\n    \"\"\"\n}",
        "nb_lignes_process": 21,
        "string_script": "    _args = args.join(\" \")\n    \"\"\"\n    multiqc . \\\n      ${_args} &> multiqc.log\n    \"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [
            "MultiQC"
        ],
        "tools_url": [
            "https://bio.tools/multiqc"
        ],
        "tools_dico": [
            {
                "name": "MultiQC",
                "uri": "https://bio.tools/multiqc",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "Sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0091",
                            "term": "Bioinformatics"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "DNA-Seq"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2428",
                                    "term": "Validation"
                                }
                            ],
                            []
                        ],
                        "input": [],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_2048",
                                "term": "Report"
                            }
                        ]
                    }
                ],
                "description": "MultiQC aggregates results from multiple bioinformatics analyses across many samples into a single report. It searches a given directory for analysis logs and compiles a HTML report. It's a general use tool, perfect for summarising the output from numerous bioinformatics tools.",
                "homepage": "http://multiqc.info/"
            }
        ],
        "inputs": [
            "location",
            "args",
            "meta"
        ],
        "nb_inputs": 3,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/multiqc:\" + params.multiqc_version",
            "publishDir \"report/multiqc\"",
            "cpus 1"
        ],
        "when": "",
        "stub": ""
    },
    "trimmomatic_pe": {
        "name_process": "trimmomatic_pe",
        "string_process": "process trimmomatic_pe {\n\n  container \"bschiffthaler/trimmomatic:\" + params.trimmomatic_version\n  publishDir \"analysis/trimmomatic\", pattern: \"*.fastq.gz\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n  cpus params.trimmomatic_cpus\n\n  input:\n    tuple path(read1), path(read2), val(name)\n    val trimmers\n    val meta\n\n  output:\n    tuple path(\"${name}_trimmed_1.fastq.gz\"), path(\"${name}_trimmed_2.fastq.gz\"), val(name), emit: data\n    path \"${name}_trimmomatic.log\", emit: log\n    val meta, emit: meta\n\n  script:\n    _trimmers = trimmers.join(\" \")\n    \"\"\"\n    run.sh PE -threads ${params.trimmomatic_cpus} \\\n      ${read1} ${read2} \\\n      ${name}_trimmed_1.fastq.gz ${name}_orphans_1.fastq.gz \\\n      ${name}_trimmed_2.fastq.gz ${name}_orphans_2.fastq.gz \\\n      ${_trimmers} &> ${name}_trimmomatic.log\n    \"\"\"\n}",
        "nb_lignes_process": 25,
        "string_script": "    _trimmers = trimmers.join(\" \")\n    \"\"\"\n    run.sh PE -threads ${params.trimmomatic_cpus} \\\n      ${read1} ${read2} \\\n      ${name}_trimmed_1.fastq.gz ${name}_orphans_1.fastq.gz \\\n      ${name}_trimmed_2.fastq.gz ${name}_orphans_2.fastq.gz \\\n      ${_trimmers} &> ${name}_trimmomatic.log\n    \"\"\"",
        "nb_lignes_script": 7,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "name",
            "read1",
            "read2",
            "trimmers",
            "meta"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/trimmomatic:\" + params.trimmomatic_version",
            "publishDir \"analysis/trimmomatic\", pattern: \"*.fastq.gz\"",
            "publishDir \"report/logs/\", pattern: \"*.log\"",
            "cpus params.trimmomatic_cpus"
        ],
        "when": "",
        "stub": ""
    },
    "fastqc_pe": {
        "name_process": "fastqc_pe",
        "string_process": "process fastqc_pe {\n\n  container \"bschiffthaler/fastqc:\" + params.fastqc_version\n  publishDir \"report/qc/${stage}\", pattern: \"*.{html,zip}\"\n  publishDir \"report/logs/\", pattern: \"*.log\"\n  executor params.executor\n  cpus 2\n\n  input:\n    val stage\n    tuple path(read1), path(read2), val(name)\n    val meta\n\n  output:\n    path \"*.{zip,html}\", emit: data\n    path \"*.log\", emit: log\n    val meta, emit: meta\n\n  \"\"\"\n  fastqc -t 2 -o . ${read1} ${read2} &> ${name}_fastqc_${stage}.log\n  \"\"\"\n}",
        "nb_lignes_process": 20,
        "string_script": "\"\"\"\n  fastqc -t 2 -o . ${read1} ${read2} &> ${name}_fastqc_${stage}.log\n  \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [
            "FastQC"
        ],
        "tools_url": [
            "https://bio.tools/fastqc"
        ],
        "tools_dico": [
            {
                "name": "FastQC",
                "uri": "https://bio.tools/fastqc",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "Sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3572",
                            "term": "Data quality management"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequence analysis"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "DNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequences"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2238",
                                    "term": "Statistical calculation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3218",
                                    "term": "Sequencing quality control"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0236",
                                    "term": "Sequence composition calculation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2238",
                                    "term": "Significance testing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2238",
                                    "term": "Statistical testing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2238",
                                    "term": "Statistical test"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2238",
                                    "term": "Statistical analysis"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3218",
                                    "term": "Sequencing QC"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3218",
                                    "term": "Sequencing quality assessment"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_0848",
                                "term": "Raw sequence"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_2955",
                                "term": "Sequence report"
                            }
                        ]
                    }
                ],
                "description": "This tool aims to provide a QC report which can spot problems or biases which originate either in the sequencer or in the starting library material. It can be run in one of two modes. It can either run as a stand alone interactive application for the immediate analysis of small numbers of FastQ files, or it can be run in a non-interactive mode where it would be suitable for integrating into a larger analysis pipeline for the systematic processing of large numbers of files.",
                "homepage": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/"
            }
        ],
        "inputs": [
            "stage",
            "name",
            "read1",
            "read2",
            "meta"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "bschiffthaler__nf-modules",
        "directive": [
            "container \"bschiffthaler/fastqc:\" + params.fastqc_version",
            "publishDir \"report/qc/${stage}\", pattern: \"*.{html,zip}\"",
            "publishDir \"report/logs/\", pattern: \"*.log\"",
            "executor params.executor",
            "cpus 2"
        ],
        "when": "",
        "stub": ""
    }
}