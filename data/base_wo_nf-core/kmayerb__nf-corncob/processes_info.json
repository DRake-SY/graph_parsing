{
    "runCorncob": {
        "name_process": "runCorncob",
        "string_process": "\nprocess runCorncob {\n    tag \"Perform corncob analysis\"\n    \n    container \"quay.io/fhcrc-microbiome/corncob\"\n    \n    label \"mem_veryhigh\"\n    \n    errorStrategy \"retry\"\n    \n    publishDir params.outdir\n\n    input:\n    set name, file(readcounts_csv_gz), file(metadata_csv), formula from input_channel\n   \n    output:\n    file \"${name}.corncob.results.csv\" into junkbonds\n\n    \"\"\"\n    #!/usr/bin/env Rscript\n\n    # Get the arguments passed in by the user\n\n    library(tidyverse)\n    library(corncob)\n    library(parallel)\n\n    Sys.setenv(\"VROOM_CONNECTION_SIZE\" = 13107200 * ${task.attempt})\n\n    numCores = ${task.cpus}\n\n    ##  READCOUNTS CSV should have columns `specimen` (first col) and `total` (last column).\n    ##  METADATA CSV should have columns `specimen` (which matches up with `specimen` from\n    ##         the recounts file), and additional columns with covariates matching `formula`\n\n    ##  corncob analysis (coefficients and p-values) are written to OUTPUT CSV on completion\n\n    print(\"Reading in ${metadata_csv}\")\n    metadata <- vroom::vroom(\"${metadata_csv}\", delim=\",\")\n\n    print(\"Reading in ${readcounts_csv_gz}\")\n    counts <- vroom::vroom(\"${readcounts_csv_gz}\", delim=\",\")\n\n    if (dim(counts)[2] > 25){\n        counts = counts[,1:25]\n    }\n    if (\"total\" %in% names(counts)){\n        print(\"total not found\")\n        total_counts <- counts[,c(\"specimen\", \"total\")]\n    }else{\n        counts[\"total\"] = apply(counts[,-which(names(counts) %in% c(\"specimen\"))],1,sum)\n        total_counts = counts[,c(\"specimen\", \"total\")]\n    }\n    \n    print(\"Merging total counts with metadata\")\n    total_and_meta <- metadata %>% \n    right_join(total_counts, by = c(\"specimen\" = \"specimen\"))\n    \n    print(head(total_and_meta))\n\n    #### Run the analysis for every individual CAG\n    print(sprintf(\"Starting to process %s columns (CAGs)\", dim(counts)[2]))\n    corn_tib <- do.call(rbind, mclapply(\n        c(2:(dim(counts)[2] - 1)),\n        function(i){\n            try_bbdml <- try(\n                counts[,c(1, i)] %>%\n                rename(W = 2) %>%\n                right_join(\n                    total_and_meta, \n                    by = c(\"specimen\" = \"specimen\")\n                ) %>%\n                corncob::bbdml(\n                    formula = cbind(W, total - W) ~ ${formula},\n                    phi.formula = ~ 1,\n                    data = .\n                )\n            )\n\n        if (class(try_bbdml) == \"bbdml\") {\n            return(\n                summary(\n                    try_bbdml\n                )\\$coef %>%\n                as_tibble %>%\n                mutate(\"parameter\" = summary(try_bbdml)\\$coef %>% row.names) %>%\n                rename(\n                    \"estimate\" = Estimate,\n                    \"std_error\" = `Std. Error`,\n                    \"p_value\" = `Pr(>|t|)`\n                ) %>%\n                select(-`t value`) %>%\n                gather(key = type, ...=estimate:p_value) %>%\n                mutate(\"CAG\" = names(counts)[i])\n            )\n        } else {\n            return(\n                tibble(\n                    \"parameter\" = \"all\",\n                    \"type\" = \"failed\", \n                    \"value\" = NA, \n                    \"CAG\" = names(counts)[i]\n                )\n            )\n        }   \n        },\n        mc.cores = numCores\n    ))\n\n    print(sprintf(\"Writing out %s rows to corncob.results.csv\", nrow(corn_tib)))\n    print(head(corn_tib))\n    write_csv(corn_tib, \"${name}.corncob.results.csv\")\n    \"\"\"\n}",
        "nb_lignes_process": 112,
        "string_script": "\"\"\"\n    #!/usr/bin/env Rscript\n\n    # Get the arguments passed in by the user\n\n    library(tidyverse)\n    library(corncob)\n    library(parallel)\n\n    Sys.setenv(\"VROOM_CONNECTION_SIZE\" = 13107200 * ${task.attempt})\n\n    numCores = ${task.cpus}\n\n    ##  READCOUNTS CSV should have columns `specimen` (first col) and `total` (last column).\n    ##  METADATA CSV should have columns `specimen` (which matches up with `specimen` from\n    ##         the recounts file), and additional columns with covariates matching `formula`\n\n    ##  corncob analysis (coefficients and p-values) are written to OUTPUT CSV on completion\n\n    print(\"Reading in ${metadata_csv}\")\n    metadata <- vroom::vroom(\"${metadata_csv}\", delim=\",\")\n\n    print(\"Reading in ${readcounts_csv_gz}\")\n    counts <- vroom::vroom(\"${readcounts_csv_gz}\", delim=\",\")\n\n    if (dim(counts)[2] > 25){\n        counts = counts[,1:25]\n    }\n    if (\"total\" %in% names(counts)){\n        print(\"total not found\")\n        total_counts <- counts[,c(\"specimen\", \"total\")]\n    }else{\n        counts[\"total\"] = apply(counts[,-which(names(counts) %in% c(\"specimen\"))],1,sum)\n        total_counts = counts[,c(\"specimen\", \"total\")]\n    }\n    \n    print(\"Merging total counts with metadata\")\n    total_and_meta <- metadata %>% \n    right_join(total_counts, by = c(\"specimen\" = \"specimen\"))\n    \n    print(head(total_and_meta))\n\n    #### Run the analysis for every individual CAG\n    print(sprintf(\"Starting to process %s columns (CAGs)\", dim(counts)[2]))\n    corn_tib <- do.call(rbind, mclapply(\n        c(2:(dim(counts)[2] - 1)),\n        function(i){\n            try_bbdml <- try(\n                counts[,c(1, i)] %>%\n                rename(W = 2) %>%\n                right_join(\n                    total_and_meta, \n                    by = c(\"specimen\" = \"specimen\")\n                ) %>%\n                corncob::bbdml(\n                    formula = cbind(W, total - W) ~ ${formula},\n                    phi.formula = ~ 1,\n                    data = .\n                )\n            )\n\n        if (class(try_bbdml) == \"bbdml\") {\n            return(\n                summary(\n                    try_bbdml\n                )\\$coef %>%\n                as_tibble %>%\n                mutate(\"parameter\" = summary(try_bbdml)\\$coef %>% row.names) %>%\n                rename(\n                    \"estimate\" = Estimate,\n                    \"std_error\" = `Std. Error`,\n                    \"p_value\" = `Pr(>|t|)`\n                ) %>%\n                select(-`t value`) %>%\n                gather(key = type, ...=estimate:p_value) %>%\n                mutate(\"CAG\" = names(counts)[i])\n            )\n        } else {\n            return(\n                tibble(\n                    \"parameter\" = \"all\",\n                    \"type\" = \"failed\", \n                    \"value\" = NA, \n                    \"CAG\" = names(counts)[i]\n                )\n            )\n        }   \n        },\n        mc.cores = numCores\n    ))\n\n    print(sprintf(\"Writing out %s rows to corncob.results.csv\", nrow(corn_tib)))\n    print(head(corn_tib))\n    write_csv(corn_tib, \"${name}.corncob.results.csv\")\n    \"\"\"",
        "nb_lignes_script": 94,
        "language_script": "Rscript",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "input_channel"
        ],
        "nb_inputs": 1,
        "outputs": [
            "junkbonds"
        ],
        "nb_outputs": 1,
        "name_workflow": "kmayerb__nf-corncob",
        "directive": [
            "tag \"Perform corncob analysis\"",
            "container \"quay.io/fhcrc-microbiome/corncob\"",
            "label \"mem_veryhigh\"",
            "errorStrategy \"retry\"",
            "publishDir params.outdir"
        ],
        "when": "",
        "stub": ""
    }
}