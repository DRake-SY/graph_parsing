{
    "KAIJU_BUILD": {
        "name_process": "KAIJU_BUILD",
        "string_process": "\nprocess KAIJU_BUILD {\n    label 'process_low'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }\n\n    container 'nanozoo/kaiju'\n    conda (params.conda ? \"bioconda::kaiju=1.7.3\" : null)\n\n    input:\n    val options\n    \n    output:\n    path 'kaijudb', emit: db\n    path \"*.version.txt\", emit: version\n\n    script:\n    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    mkdir kaijudb && cd kaijudb && \\\\\n    kaiju-makedb $ioptions.args \\\\\n        -s $params.kaiju_db_name \\\\\n        -t $task.cpus && \\\\\n    cd ..\n\n    echo \\$(kaiju -h 2>&1) | head -1 | cut -d ' ' -f2  > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    mkdir kaijudb && cd kaijudb && \\\\\n    kaiju-makedb $ioptions.args \\\\\n        -s $params.kaiju_db_name \\\\\n        -t $task.cpus && \\\\\n    cd ..\n\n    echo \\$(kaiju -h 2>&1) | head -1 | cut -d ' ' -f2  > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 10,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "options"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }",
            "container 'nanozoo/kaiju'",
            "conda (params.conda ? \"bioconda::kaiju=1.7.3\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "KAIJU": {
        "name_process": "KAIJU",
        "string_process": "\nprocess KAIJU {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container 'nanozoo/kaiju'\n    conda (params.conda ? \"bioconda::kaiju=1.7.3\" : null)\n\n\tinput:\n    tuple val(meta), path(fasta)\n    path db\n    val options\n\n\toutput:\n    tuple val(meta), path('*-taxonomy.tsv'), emit: taxonomy\n    tuple val(meta), path('*-taxids.txt'), emit: taxids\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    kaiju -t $db/nodes.dmp -f $db/kaiju_db_*.fmi -i $fasta -o ${prefix}-taxonomy.tsv\n\n    grep -E '^C' ${prefix}-taxonomy.tsv | cut -f3 > ${prefix}-taxids.txt    \n\n    echo \\$(kaiju -h 2>&1) | head -1 | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"\n}",
        "nb_lignes_process": 32,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    kaiju -t $db/nodes.dmp -f $db/kaiju_db_*.fmi -i $fasta -o ${prefix}-taxonomy.tsv\n\n    grep -E '^C' ${prefix}-taxonomy.tsv | cut -f3 > ${prefix}-taxids.txt    \n\n    echo \\$(kaiju -h 2>&1) | head -1 | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"",
        "nb_lignes_script": 9,
        "language_script": "bash",
        "tools": [
            "Kaiju"
        ],
        "tools_url": [
            "https://bio.tools/kaiju"
        ],
        "tools_dico": [
            {
                "name": "Kaiju",
                "uri": "https://bio.tools/kaiju",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3174",
                            "term": "Metagenomics"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3460",
                                    "term": "Taxonomic classification"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3460",
                                    "term": "Taxonomy assignment"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_2975",
                                "term": "Nucleic acid sequence (raw)"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_3028",
                                "term": "Taxonomy"
                            }
                        ]
                    }
                ],
                "description": "Program for the taxonomic assignment of high-throughput sequencing reads, e.g., Illumina or Roche/454, from whole-genome sequencing of metagenomic DNA. Reads are directly assigned to taxa using the NCBI taxonomy and a reference database of protein sequences from Bacteria, Archaea, Fungi, microbial eukaryotes and viruses.",
                "homepage": "http://kaiju.binf.ku.dk"
            }
        ],
        "inputs": [
            "meta",
            "fasta",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'nanozoo/kaiju'",
            "conda (params.conda ? \"bioconda::kaiju=1.7.3\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "KRAKEN2_BUILD": {
        "name_process": "KRAKEN2_BUILD",
        "string_process": "\nprocess KRAKEN2_BUILD {\n    tag {\"download_kraken_db\"}\n    label 'process_low'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }\n\n    container 'staphb/kraken2'\n    conda (params.conda ? \"bioconda::kraken2=2.0.9beta\" : null)\n\n    input:\n    val options\n    \n    output:\n    path 'kraken2-standard-db', emit: db\n    path \"*.version.txt\", emit: version\n\n    script:\n    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    kraken2-build $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --db kraken2-db\n\n    kraken2-build -v | sed 's/.* version //' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 28,
        "string_script": "    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    kraken2-build $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --db kraken2-db\n\n    kraken2-build -v | sed 's/.* version //' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 8,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "options"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"download_kraken_db\"}",
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }",
            "container 'staphb/kraken2'",
            "conda (params.conda ? \"bioconda::kraken2=2.0.9beta\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "KRAKEN2": {
        "name_process": "KRAKEN2",
        "string_process": "\nprocess KRAKEN2 {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container 'staphb/kraken2:2.0.8-beta_hv'\n    conda (params.conda ? \"bioconda::kraken2=2.0.9beta\" : null)\n\n\tinput:\n    tuple val(meta), path(fasta)\n    path db\n    val options\n\n\toutput:\n    tuple val(meta), path('*-report.tsv'), emit: report\n    tuple val(meta), path('*-taxonomy.tsv'), emit: taxonomy\n    tuple val(meta), path('*-taxids.txt'), emit: taxids\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    kraken2 $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --db $db \\\\\n        --confidence $params.confidence \\\\\n        --report ${prefix}-report.tsv \\\\\n        --output ${prefix}-taxonomy.tsv \\\\\n        $fasta\n\n    grep -E '^C' ${prefix}-taxonomy.tsv | cut -f3 > ${prefix}-taxids.txt\n    \n    kraken2 -v | head -1 | sed 's/.* version //' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 39,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    kraken2 $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --db $db \\\\\n        --confidence $params.confidence \\\\\n        --report ${prefix}-report.tsv \\\\\n        --output ${prefix}-taxonomy.tsv \\\\\n        $fasta\n\n    grep -E '^C' ${prefix}-taxonomy.tsv | cut -f3 > ${prefix}-taxids.txt\n    \n    kraken2 -v | head -1 | sed 's/.* version //' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 15,
        "language_script": "bash",
        "tools": [
            "kraken2"
        ],
        "tools_url": [
            "https://bio.tools/kraken2"
        ],
        "tools_dico": [
            {
                "name": "kraken2",
                "uri": "https://bio.tools/kraken2",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0637",
                            "term": "Taxonomy"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3174",
                            "term": "Metagenomics"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3460",
                                    "term": "Taxonomic classification"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3460",
                                    "term": "Taxonomy assignment"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_3494",
                                "term": "DNA sequence"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_3028",
                                "term": "Taxonomy"
                            }
                        ]
                    }
                ],
                "description": "Kraken 2 is the newest version of Kraken, a taxonomic classification system using exact k-mer matches to achieve high accuracy and fast classification speeds. This classifier matches each k-mer within a query sequence to the lowest common ancestor (LCA) of all genomes containing the given k-mer. The k-mer assignments inform the classification algorithm.",
                "homepage": "https://ccb.jhu.edu/software/kraken2/"
            }
        ],
        "inputs": [
            "meta",
            "fasta",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'staphb/kraken2:2.0.8-beta_hv'",
            "conda (params.conda ? \"bioconda::kraken2=2.0.9beta\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "MAXBIN2": {
        "name_process": "MAXBIN2",
        "string_process": "\nprocess MAXBIN2 {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n\n    container 'nanozoo/maxbin2'\n                                                                           \n    conda (params.conda ? 'bioconda::maxbin2=2.2.7 perl-lwp-simple' : null)\n\n    input:\n    tuple val(meta), path(fasta), path(coverage)\n    val options\n\n    output:\n    tuple val(meta), path('maxbin2-*.csv'), emit: bins\n    path \"*.version.txt\", emit: version\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    def cov_arg = coverage.withIndex()\n        .collect{v, i -> \"-abund${i+1} ${v}\"}\n        .join(' ')\n        .replaceFirst('abund1', 'abund')\n    \"\"\"\n    run_MaxBin.pl $ioptions.args \\\\\n        -contig $fasta $cov_arg \\\\\n        -out maxbin-$prefix \\\\\n        -thread $task.cpus\n\n    # Make assignment file\n    for fa in `ls maxbin-${prefix}*.fasta`; do\n        bin_id=\\$(echo \\$fa | cut -d '.' -f2 | sed 's/^0*//')\n        grep '^>' \\$fa | cut -c 2- | awk -v b=\\$bin_id '{print \\$1\",\"b}' >> maxbin2-${prefix}.csv\n    done\n\n    run_MaxBin.pl -v | head -1 > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 42,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    def cov_arg = coverage.withIndex()\n        .collect{v, i -> \"-abund${i+1} ${v}\"}\n        .join(' ')\n        .replaceFirst('abund1', 'abund')\n    \"\"\"\n    run_MaxBin.pl $ioptions.args \\\\\n        -contig $fasta $cov_arg \\\\\n        -out maxbin-$prefix \\\\\n        -thread $task.cpus\n\n    # Make assignment file\n    for fa in `ls maxbin-${prefix}*.fasta`; do\n        bin_id=\\$(echo \\$fa | cut -d '.' -f2 | sed 's/^0*//')\n        grep '^>' \\$fa | cut -c 2- | awk -v b=\\$bin_id '{print \\$1\",\"b}' >> maxbin2-${prefix}.csv\n    done\n\n    run_MaxBin.pl -v | head -1 > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 20,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "coverage",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'nanozoo/maxbin2'",
            "conda (params.conda ? 'bioconda::maxbin2=2.2.7 perl-lwp-simple' : null)"
        ],
        "when": "",
        "stub": ""
    },
    "CONCOCT": {
        "name_process": "CONCOCT",
        "string_process": "\nprocess CONCOCT {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container \"quay.io/biocontainers/concoct:1.1.0--py38h7be5676_2\"\n    conda (params.conda ? \"bioconda::concoct=1.1.0\" : null)\n\n    input:\n    tuple val(meta), path(fasta), path(coverage)\n    val options\n\n    output:\n    tuple val(meta), path(\"concoct_${meta.id}.csv\"), emit: bins\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"    \n    \"\"\"\n    concoct $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --composition_file ${fasta} \\\\\n        --coverage_file ${coverage}\n\n    tail -n+2 clustering_gt*.csv > concoct_${meta.id}.csv\n\n    concoct --version > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 33,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"    \n    \"\"\"\n    concoct $ioptions.args \\\\\n        --threads $task.cpus \\\\\n        --composition_file ${fasta} \\\\\n        --coverage_file ${coverage}\n\n    tail -n+2 clustering_gt*.csv > concoct_${meta.id}.csv\n\n    concoct --version > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 12,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "coverage",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container \"quay.io/biocontainers/concoct:1.1.0--py38h7be5676_2\"",
            "conda (params.conda ? \"bioconda::concoct=1.1.0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "DL_VIRAL_PROTEIN_DB": {
        "name_process": "DL_VIRAL_PROTEIN_DB",
        "string_process": "\nprocess DL_VIRAL_PROTEIN_DB {\n    publishDir params.dbdir, mode: 'copy'\n    container = 'nakor/virus_extraction'\n\n    output:\n    path 'refseq_viral_proteins.dmnd'\n\n    script:\n    \"\"\"\n    wget https://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.{1,2}.protein.faa.gz\n    cat viral.*.protein.faa.gz | unpigz -p $task.cpus > viral.protein.faa\n    diamond makedb --threads $task.cpus --in viral.protein.faa --db refseq_viral_proteins\n    \"\"\"        \n}",
        "nb_lignes_process": 13,
        "string_script": "    \"\"\"\n    wget https://ftp.ncbi.nlm.nih.gov/refseq/release/viral/viral.{1,2}.protein.faa.gz\n    cat viral.*.protein.faa.gz | unpigz -p $task.cpus > viral.protein.faa\n    diamond makedb --threads $task.cpus --in viral.protein.faa --db refseq_viral_proteins\n    \"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [
            "Diamond"
        ],
        "tools_url": [
            "https://bio.tools/diamond"
        ],
        "tools_dico": [
            {
                "name": "Diamond",
                "uri": "https://bio.tools/diamond",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequence analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Proteins"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequences"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Protein bioinformatics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Protein informatics"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0258",
                                    "term": "Sequence alignment analysis"
                                }
                            ],
                            []
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Sequence aligner for protein and translated DNA searches and functions as a drop-in replacement for the NCBI BLAST software tools. It is suitable for protein-protein search as well as DNA-protein search on short reads and longer sequences including contigs and assemblies, providing a speedup of BLAST ranging up to x20,000.",
                "homepage": "https://github.com/bbuchfink/diamond"
            }
        ],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "publishDir params.dbdir, mode: 'copy'",
            "container = 'nakor/virus_extraction'"
        ],
        "when": "",
        "stub": ""
    },
    "DIAMOND_BLASTX": {
        "name_process": "DIAMOND_BLASTX",
        "string_process": "\nprocess DIAMOND_BLASTX {\n    tag {\"${meta.id}\"}\n    publishDir params.outdir+\"/diamond\", mode: \"copy\"\n                                           \n    \n    input:\n    tuple val(meta), path(fasta)\n    path db\n    val options\n\n    output:\n    tuple val(meta), path('*'), emit: 'all'\n    tuple val(meta), path(\"diamond-${meta.id}.txt\"), emit: 'ctg_ids'    \n    \n    script:\n    def ioptions = initOptions(options)\n    \"\"\"\n    diamond blastx $ioptions.args -b 6 -d ${db} -q ${fasta} -o diamond_matches_on_refseq_${meta.id}.m8 --threads $task.cpus\n    cut -f1 diamond_matches_on_refseq_${meta.id}.m8 | uniq -c | sort -rnk1 \\\n        | awk '{OFS=\",\"}{print \\$2,\\$1}' > diamond_ctg_hit_counts_${meta.id}.txt\n    cut -d, -f1 diamond_ctg_hit_counts_${meta.id}.txt > diamond-${meta.id}.txt\n    \"\"\"\n}",
        "nb_lignes_process": 22,
        "string_script": "    def ioptions = initOptions(options)\n    \"\"\"\n    diamond blastx $ioptions.args -b 6 -d ${db} -q ${fasta} -o diamond_matches_on_refseq_${meta.id}.m8 --threads $task.cpus\n    cut -f1 diamond_matches_on_refseq_${meta.id}.m8 | uniq -c | sort -rnk1 \\\n        | awk '{OFS=\",\"}{print \\$2,\\$1}' > diamond_ctg_hit_counts_${meta.id}.txt\n    cut -d, -f1 diamond_ctg_hit_counts_${meta.id}.txt > diamond-${meta.id}.txt\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [
            "Diamond"
        ],
        "tools_url": [
            "https://bio.tools/diamond"
        ],
        "tools_dico": [
            {
                "name": "Diamond",
                "uri": "https://bio.tools/diamond",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequence analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Proteins"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequences"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Protein bioinformatics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0078",
                            "term": "Protein informatics"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0258",
                                    "term": "Sequence alignment analysis"
                                }
                            ],
                            []
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Sequence aligner for protein and translated DNA searches and functions as a drop-in replacement for the NCBI BLAST software tools. It is suitable for protein-protein search as well as DNA-protein search on short reads and longer sequences including contigs and assemblies, providing a speedup of BLAST ranging up to x20,000.",
                "homepage": "https://github.com/bbuchfink/diamond"
            }
        ],
        "inputs": [
            "meta",
            "fasta",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [
            "meta",
            "meta"
        ],
        "nb_outputs": 2,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "publishDir params.outdir+\"/diamond\", mode: \"copy\""
        ],
        "when": "",
        "stub": ""
    },
    "CHECKV_END_TO_END": {
        "name_process": "CHECKV_END_TO_END",
        "string_process": "\nprocess CHECKV_END_TO_END {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}/checkv\", mode: 'copy'\n    \n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container \"quay.io/biocontainers/checkv:0.7.0--py_1\"\n    conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)\n\n    input:\n    tuple val(meta), path(fasta)\n    path db\n    val options\n\n    output:\n    tuple val(meta), path(\"checkv-*\"), emit: all\n    path \"*.version.txt\", emit: version\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    checkv end_to_end -d $db -t $task.cpus $fasta checkv-${meta.id}\n    checkv --help | head -1 | cut -d ' ' -f2 | sed 's/[v:]//g' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    checkv end_to_end -d $db -t $task.cpus $fasta checkv-${meta.id}\n    checkv --help | head -1 | cut -d ' ' -f2 | sed 's/[v:]//g' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}/checkv\", mode: 'copy'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container \"quay.io/biocontainers/checkv:0.7.0--py_1\"",
            "conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "CHECKV": {
        "name_process": "CHECKV",
        "string_process": "\nprocess CHECKV {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}/checkv\", mode: 'copy'\n    \n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container \"quay.io/biocontainers/checkv:0.7.0--py_1\"\n    conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)\n\n    input:\n    tuple val(meta), path(fasta)\n    val options\n\n    output:\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n\n    checkv -v > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n\n    checkv -v > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "options"
        ],
        "nb_inputs": 3,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}/checkv\", mode: 'copy'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container \"quay.io/biocontainers/checkv:0.7.0--py_1\"",
            "conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "PROKKA_SETUPDB": {
        "name_process": "PROKKA_SETUPDB",
        "string_process": "\nprocess PROKKA_SETUPDB {\n    label 'process_low'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }\n\n    container 'quay.io/biocontainers/prokka:1.14.6--pl526_0'\n    conda (params.conda ? \"bioconda::prokka=1.14.6-0\" : null)\n\n    input:\n    val options\n    \n    output:\n    path \"db\", emit: db\n    path \"*.version.txt\", emit: version\n\n    script:\n    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    cp -r \\$(dirname \\$(which prokka))/../db .\n    prokka $ioptions.args --dbdir db --setupdb\n    prokka --version | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"\n}",
        "nb_lignes_process": 25,
        "string_script": "    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    \"\"\"\n    cp -r \\$(dirname \\$(which prokka))/../db .\n    prokka $ioptions.args --dbdir db --setupdb\n    prokka --version | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [
            "Prokka"
        ],
        "tools_url": [
            "https://bio.tools/prokka"
        ],
        "tools_dico": [
            {
                "name": "Prokka",
                "uri": "https://bio.tools/prokka",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0621",
                            "term": "Model organisms"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0622",
                            "term": "Genomics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0781",
                            "term": "Virology"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0621",
                            "term": "Organisms"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "Coding region prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0362",
                                    "term": "Genome annotation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "ORF prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "ORF finding"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene finding"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene calling"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Software tool to annotate bacterial, archaeal and viral genomes quickly and produce standards-compliant output files.",
                "homepage": "https://github.com/tseemann/prokka"
            }
        ],
        "inputs": [
            "options"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:'') }",
            "container 'quay.io/biocontainers/prokka:1.14.6--pl526_0'",
            "conda (params.conda ? \"bioconda::prokka=1.14.6-0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "PROKKA": {
        "name_process": "PROKKA",
        "string_process": "\nprocess PROKKA {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container 'quay.io/biocontainers/prokka:1.14.6--pl526_0'\n    conda (params.conda ? \"bioconda::prokka=1.14.6-0\" : null)\n\n\tinput:\n    tuple val(meta), path(fasta)\n    path db\n    val options\n\n\toutput:\n    path \"*\", emit: annotation\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    prokka --cpus $task.cpus $ioptions.args $fasta\n\n    prokka --version | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    prokka --cpus $task.cpus $ioptions.args $fasta\n\n    prokka --version | cut -d ' ' -f2  > ${software}.version.txt    \n    \"\"\"",
        "nb_lignes_script": 7,
        "language_script": "bash",
        "tools": [
            "Prokka"
        ],
        "tools_url": [
            "https://bio.tools/prokka"
        ],
        "tools_dico": [
            {
                "name": "Prokka",
                "uri": "https://bio.tools/prokka",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0621",
                            "term": "Model organisms"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0622",
                            "term": "Genomics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0781",
                            "term": "Virology"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0621",
                            "term": "Organisms"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "Coding region prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0362",
                                    "term": "Genome annotation"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "ORF prediction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0436",
                                    "term": "ORF finding"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene finding"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2454",
                                    "term": "Gene calling"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Software tool to annotate bacterial, archaeal and viral genomes quickly and produce standards-compliant output files.",
                "homepage": "https://github.com/tseemann/prokka"
            }
        ],
        "inputs": [
            "meta",
            "fasta",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'quay.io/biocontainers/prokka:1.14.6--pl526_0'",
            "conda (params.conda ? \"bioconda::prokka=1.14.6-0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "CHECKV_DOWNLOAD_DATABASE": {
        "name_process": "CHECKV_DOWNLOAD_DATABASE",
        "string_process": "\nprocess CHECKV_DOWNLOAD_DATABASE {\n    label 'process_low'\n    \n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    \n    container \"quay.io/biocontainers/checkv:0.7.0--py_1\"\n    conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)\n\n    output:\n    path \"checkv*\", emit: db\n    path \"*.version.txt\", emit: version\n    \n    script:\n    def software = getSoftwareName(task.process)\n    \"\"\"\n    checkv download_database .\n    checkv --help | head -1 | cut -d ' ' -f2 | sed 's/[v:]//g' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 20,
        "string_script": "    def software = getSoftwareName(task.process)\n    \"\"\"\n    checkv download_database .\n    checkv --help | head -1 | cut -d ' ' -f2 | sed 's/[v:]//g' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container \"quay.io/biocontainers/checkv:0.7.0--py_1\"",
            "conda (params.conda ? \"bioconda::checkv=0.7.0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "VIBRANT_SETUP": {
        "name_process": "VIBRANT_SETUP",
        "string_process": "\nprocess VIBRANT_SETUP {\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    container 'nakor/vibrant'\n    \n\tinput:\n    tuple val(meta), path(fasta)\n    path vibrant_db\n    path vibrant_files\n    val options\n\n\toutput:\n    tuple val(meta), path('*'), emit: all\n    tuple val(meta), path(\"vibrant-*.txt\"), emit: ctg_ids\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    \"\"\"\n    VIBRANT_setup.py $ioptions.args\n\n    VIBRANT_setup.py --version | sed 's/VIBRANT //' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 25,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    \"\"\"\n    VIBRANT_setup.py $ioptions.args\n\n    VIBRANT_setup.py --version | sed 's/VIBRANT //' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "vibrant_db",
            "vibrant_files",
            "options"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/vibrant'"
        ],
        "when": "",
        "stub": ""
    },
    "DL_VIRSORTER_DB": {
        "name_process": "DL_VIRSORTER_DB",
        "string_process": "\nprocess DL_VIRSORTER_DB {\n    label 'process_low'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    output:\n    path 'vs_db'\n\n    script:\n    \"\"\"\n    wget https://zenodo.org/record/1168727/files/virsorter-data-v2.tar.gz\n    tar -xvzf virsorter-data-v2.tar.gz\n    mv virsorter-data vs_db\n    \"\"\"    \n}",
        "nb_lignes_process": 14,
        "string_script": "    \"\"\"\n    wget https://zenodo.org/record/1168727/files/virsorter-data-v2.tar.gz\n    tar -xvzf virsorter-data-v2.tar.gz\n    mv virsorter-data vs_db\n    \"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }"
        ],
        "when": "",
        "stub": ""
    },
    "VIRSORTER": {
        "name_process": "VIRSORTER",
        "string_process": "\nprocess VIRSORTER {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    container 'nakor/virsorter'\n    \n    input:\n    tuple val(meta), path(fasta)\n    path vs_db\n    val options\n\n    output:\n    tuple val(meta), path(\"virsorter-output-*\"), emit: all\n    tuple val(meta), path (\"virsorter-*.txt\"), emit: ctg_ids\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    wrapper_phage_contigs_sorter_iPlant.pl $ioptions.args \\\n        -f $fasta \\\n        --ncpu $task.cpus \\\n        --wdir virsorter-output-$prefix \\\n        --data-dir $vs_db --db 1\n    \n    grep \"^VIRSorter\" virsorter-output-$prefix/VIRSorter_global-phage-signal.csv \\\n        | cut -d, -f1 \\\n        | sed 's/VIRSorter_//' \\\n        | sed 's/-circular//' \\\n        > virsorter-${prefix}.txt\n    \"\"\"\n}",
        "nb_lignes_process": 34,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    wrapper_phage_contigs_sorter_iPlant.pl $ioptions.args \\\n        -f $fasta \\\n        --ncpu $task.cpus \\\n        --wdir virsorter-output-$prefix \\\n        --data-dir $vs_db --db 1\n    \n    grep \"^VIRSorter\" virsorter-output-$prefix/VIRSorter_global-phage-signal.csv \\\n        | cut -d, -f1 \\\n        | sed 's/VIRSorter_//' \\\n        | sed 's/-circular//' \\\n        > virsorter-${prefix}.txt\n    \"\"\"",
        "nb_lignes_script": 15,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "vs_db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/virsorter'"
        ],
        "when": "",
        "stub": ""
    },
    "COCONET_RUN": {
        "name_process": "COCONET_RUN",
        "string_process": "\nprocess COCONET_RUN {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n\n    container 'nakor/coconet'\n                                                  \n                                                                     \n    \n    input:\n    tuple val(meta), file(fasta), file(coverage)\n    val options\n\n    output:\n    tuple val(meta), path(\"coconet_bins-*.csv\"), emit: bins\n    tuple val(meta), path(\"coconet*\"), emit: all\n    tuple val(meta), path(\"coconet*/*.log\"), emit: log\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n\n    def cov_list = coverage instanceof List ? coverage : [coverage]\n    def cov_flag = cov_list[0].getExtension() == 'bam' ? \"--bam\" : \"--h5\"    \n    \"\"\"\n    coconet run $ioptions.args \\\\\n        --fasta $fasta \\\\\n        $cov_flag ${cov_list.join(' ')} \\\\\n        --output coconet-$prefix \\\\\n        --thread $task.cpus\n\n    cp coconet-$prefix/bins_*.csv coconet_bins-${prefix}.csv\n\n    coconet --version > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 40,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n\n    def cov_list = coverage instanceof List ? coverage : [coverage]\n    def cov_flag = cov_list[0].getExtension() == 'bam' ? \"--bam\" : \"--h5\"    \n    \"\"\"\n    coconet run $ioptions.args \\\\\n        --fasta $fasta \\\\\n        $cov_flag ${cov_list.join(' ')} \\\\\n        --output coconet-$prefix \\\\\n        --thread $task.cpus\n\n    cp coconet-$prefix/bins_*.csv coconet_bins-${prefix}.csv\n\n    coconet --version > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 16,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "coverage",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'nakor/coconet'"
        ],
        "when": "",
        "stub": ""
    },
    "VIRSORTER2_SETUP": {
        "name_process": "VIRSORTER2_SETUP",
        "string_process": "\nprocess VIRSORTER2_SETUP {\n    label \"process_low\"\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    container \"nakor/virsorter\"\n\n    output:\n    path \"virsorter2_db\", emit: db\n    path \"*.version.txt\", emit: version\n\n    script:\n    def software = getSoftwareName(task.process)\n    \"\"\"\n    virsorter setup -d virsorter2_db -j $task.cpus\n    virsorter --version | sed \"s/.*version //\" > ${software}.version.txt\n    \"\"\"    \n}",
        "nb_lignes_process": 17,
        "string_script": "    def software = getSoftwareName(task.process)\n    \"\"\"\n    virsorter setup -d virsorter2_db -j $task.cpus\n    virsorter --version | sed \"s/.*version //\" > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 4,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label \"process_low\"",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container \"nakor/virsorter\""
        ],
        "when": "",
        "stub": ""
    },
    "VIBRANT_DB": {
        "name_process": "VIBRANT_DB",
        "string_process": "\nprocess VIBRANT_DB {\n    label \"process_low\"\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n\n    container 'nakor/vibrant'\n    \n    output:\n    path \"$db_name/databases\", emit: db\n    path \"$db_name/files\", emit: files\n\n    script:\n    def db_name = params.vibrant_db.tokenize('/')[-1]\n    \"\"\"\n    mkdir -p \"${db_name}/databases\" && cd \"${db_name}/databases\"\n    vibrant_dir=\\$(dirname \\$(which VIBRANT_setup.py))\n    cp -r \"\\$vibrant_dir\"/profile_names .\n    cp -r \"\\$vibrant_dir\"/../files ..\n\n    wget -qO- http://fileshare.csb.univie.ac.at/vog/vog94/vog.hmm.tar.gz | tar xz\n    wget -q ftp://ftp.ebi.ac.uk/pub/databases/Pfam/releases/Pfam32.0/Pfam-A.hmm.gz \\\n        && gunzip Pfam-A.hmm.gz\n    wget -qO- ftp://ftp.genome.jp/pub/db/kofam/archives/2019-08-10/profiles.tar.gz | tar xz\n\n    for v in VOG*.hmm; do \n\t    cat \\$v >> vog_temp.HMM\n    done\n\n    for k in profiles/K*.hmm; do \n\t    cat \\$k >> kegg_temp.HMM\n    done\n\n    rm -r VOG0*.hmm VOG1*.hmm VOG2*.hmm profiles\n\n    hmmfetch -o VOGDB94_phage.HMM -f vog_temp.HMM profile_names/VIBRANT_vog_profiles.txt >> VIBRANT_setup.log\n    hmmfetch -o KEGG_profiles_prokaryotes.HMM -f kegg_temp.HMM profile_names/VIBRANT_kegg_profiles.txt >> VIBRANT_setup.log\n    \n    rm vog_temp.HMM kegg_temp.HMM\n    mv Pfam-A.hmm Pfam-A_v32.HMM\n\n    hmmpress VOGDB94_phage.HMM >> VIBRANT_setup.log\n    hmmpress KEGG_profiles_prokaryotes.HMM >> VIBRANT_setup.log\n    hmmpress Pfam-A_v32.HMM >> VIBRANT_setup.log\n    \"\"\"\n}",
        "nb_lignes_process": 45,
        "string_script": "    def db_name = params.vibrant_db.tokenize('/')[-1]\n    \"\"\"\n    mkdir -p \"${db_name}/databases\" && cd \"${db_name}/databases\"\n    vibrant_dir=\\$(dirname \\$(which VIBRANT_setup.py))\n    cp -r \"\\$vibrant_dir\"/profile_names .\n    cp -r \"\\$vibrant_dir\"/../files ..\n\n    wget -qO- http://fileshare.csb.univie.ac.at/vog/vog94/vog.hmm.tar.gz | tar xz\n    wget -q ftp://ftp.ebi.ac.uk/pub/databases/Pfam/releases/Pfam32.0/Pfam-A.hmm.gz \\\n        && gunzip Pfam-A.hmm.gz\n    wget -qO- ftp://ftp.genome.jp/pub/db/kofam/archives/2019-08-10/profiles.tar.gz | tar xz\n\n    for v in VOG*.hmm; do \n\t    cat \\$v >> vog_temp.HMM\n    done\n\n    for k in profiles/K*.hmm; do \n\t    cat \\$k >> kegg_temp.HMM\n    done\n\n    rm -r VOG0*.hmm VOG1*.hmm VOG2*.hmm profiles\n\n    hmmfetch -o VOGDB94_phage.HMM -f vog_temp.HMM profile_names/VIBRANT_vog_profiles.txt >> VIBRANT_setup.log\n    hmmfetch -o KEGG_profiles_prokaryotes.HMM -f kegg_temp.HMM profile_names/VIBRANT_kegg_profiles.txt >> VIBRANT_setup.log\n    \n    rm vog_temp.HMM kegg_temp.HMM\n    mv Pfam-A.hmm Pfam-A_v32.HMM\n\n    hmmpress VOGDB94_phage.HMM >> VIBRANT_setup.log\n    hmmpress KEGG_profiles_prokaryotes.HMM >> VIBRANT_setup.log\n    hmmpress Pfam-A_v32.HMM >> VIBRANT_setup.log\n    \"\"\"",
        "nb_lignes_script": 31,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label \"process_low\"",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/vibrant'"
        ],
        "when": "",
        "stub": ""
    },
    "VIBRANT_RUN": {
        "name_process": "VIBRANT_RUN",
        "string_process": "\nprocess VIBRANT_RUN {\n    tag {\"${meta.id}\"}\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    container 'nakor/vibrant'\n    \n\tinput:\n    tuple val(meta), path(fasta)\n    path vibrant_db\n    path vibrant_files\n    val options\n\n\toutput:\n    tuple val(meta), path('*'), emit: all\n    tuple val(meta), path(\"vibrant-*.txt\"), emit: ctg_ids\n    path \"*.version.txt\", emit: log\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \n    def radical = \"${fasta.getSimpleName()}\"\n    def result_path = \"VIBRANT_${radical}/VIBRANT_results_${radical}/VIBRANT_machine_${radical}.tsv\"\n    \"\"\"\n    VIBRANT_run.py $ioptions.args -i $fasta -t $task.cpus -d $vibrant_db -m $vibrant_files\n    awk -F\"\\\\t\" '\\$2==\"virus\"' $result_path | cut -d ' ' -f 1 >> vibrant-${prefix}.txt\n\n    VIBRANT_run.py --version | sed 's/VIBRANT //' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 31,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \n    def radical = \"${fasta.getSimpleName()}\"\n    def result_path = \"VIBRANT_${radical}/VIBRANT_results_${radical}/VIBRANT_machine_${radical}.tsv\"\n    \"\"\"\n    VIBRANT_run.py $ioptions.args -i $fasta -t $task.cpus -d $vibrant_db -m $vibrant_files\n    awk -F\"\\\\t\" '\\$2==\"virus\"' $result_path | cut -d ' ' -f 1 >> vibrant-${prefix}.txt\n\n    VIBRANT_run.py --version | sed 's/VIBRANT //' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "vibrant_db",
            "vibrant_files",
            "options"
        ],
        "nb_inputs": 5,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'nakor/vibrant'"
        ],
        "when": "",
        "stub": ""
    },
    "METABAT2": {
        "name_process": "METABAT2",
        "string_process": "\nprocess METABAT2 {\n    tag {\"${meta.id}\"}\n    label 'process_low'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n    \n    container 'quay.io/biocontainers/metabat2:2.15--h986a166_1'\n    conda (params.conda ? \"bioconda::metabat2=2.15\" : null)\n\n    input:\n    tuple val(meta), path(fasta), path(coverage)\n    val options\n\n    output:\n    tuple val(meta), path(\"metabat2-${meta.id}.csv\"), emit: bins\n    path \"*.version.txt\", emit: version\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    gzip -c $fasta > contigs.fasta.gz && \\\\\n    metabat2 $ioptions.args \\\\\n        --inFile contigs.fasta.gz \\\\\n        --abdFile $coverage \\\\\n        --outFile metabat2-${meta.id} \\\\\n        --unbinned \\\\\n        --numThreads $task.cpus\n\n    # Make assignment file\n    for f in `ls *.fa`; do\n        bin=`echo \\$f | cut -d'.' -f2`\n\n        if [[ \"\\$bin\" =~ ^[0-9]+\\$ ]]; then\n            grep '^>' \\$f | cut -c2- \\\\\n                | awk -v b=\\$bin '{print \\$1\",\"b}' \\\\\n                >> \"metabat2-${meta.id}.csv\"\n        else\n            grep '^>' \\$f | cut -c2- \\\\\n                | awk -v b=\\$bin '{print \\$1\",\"b\"-\"NR}' \\\\\n                >> \"metabat2-${meta.id}.csv\"\n        fi\n    done\n\n    rm contigs.fasta.gz\n\n    metabat2 -h 2>&1 | head | grep version > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 51,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    gzip -c $fasta > contigs.fasta.gz && \\\\\n    metabat2 $ioptions.args \\\\\n        --inFile contigs.fasta.gz \\\\\n        --abdFile $coverage \\\\\n        --outFile metabat2-${meta.id} \\\\\n        --unbinned \\\\\n        --numThreads $task.cpus\n\n    # Make assignment file\n    for f in `ls *.fa`; do\n        bin=`echo \\$f | cut -d'.' -f2`\n\n        if [[ \"\\$bin\" =~ ^[0-9]+\\$ ]]; then\n            grep '^>' \\$f | cut -c2- \\\\\n                | awk -v b=\\$bin '{print \\$1\",\"b}' \\\\\n                >> \"metabat2-${meta.id}.csv\"\n        else\n            grep '^>' \\$f | cut -c2- \\\\\n                | awk -v b=\\$bin '{print \\$1\",\"b\"-\"NR}' \\\\\n                >> \"metabat2-${meta.id}.csv\"\n        fi\n    done\n\n    rm contigs.fasta.gz\n\n    metabat2 -h 2>&1 | head | grep version > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 30,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "coverage",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'quay.io/biocontainers/metabat2:2.15--h986a166_1'",
            "conda (params.conda ? \"bioconda::metabat2=2.15\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "VIRSORTER2_RUN": {
        "name_process": "VIRSORTER2_RUN",
        "string_process": "\nprocess VIRSORTER2_RUN {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    container 'nakor/virsorter'\n\n    input:\n    tuple val(meta), path(fasta)\n    path vs2_db\n    val options\n\n    output:\n    tuple val(meta), path('final-viral-score.tsv'), emit: all\n    tuple val(meta), path(\"virsorter2-*.txt\"), emit: ctg_ids\n    path \"*.version.txt\", emit: version\n    \n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    #!/usr/bin/env bash\n\n    virsorter run $ioptions.args  -w out -i $fasta -j $task.cpus -d $vs2_db\n    mv out/final-viral-score.tsv .\n    tail -n+2 final-viral-score.tsv | cut -f1 | cut -d'|' -f1 > virsorter2-${prefix}.txt\n\n    virsorter --version | sed 's/.*version //' > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 31,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    #!/usr/bin/env bash\n\n    virsorter run $ioptions.args  -w out -i $fasta -j $task.cpus -d $vs2_db\n    mv out/final-viral-score.tsv .\n    tail -n+2 final-viral-score.tsv | cut -f1 | cut -d'|' -f1 > virsorter2-${prefix}.txt\n\n    virsorter --version | sed 's/.*version //' > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 11,
        "language_script": "bash",
        "tools": [
            "denvax"
        ],
        "tools_url": [
            "https://bio.tools/denvax"
        ],
        "tools_dico": [
            {
                "name": "denvax",
                "uri": "https://bio.tools/denvax",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3379",
                            "term": "Preclinical and clinical studies"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3399",
                            "term": "Geriatric medicine"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3305",
                            "term": "Public health and epidemiology"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3399",
                            "term": "https://en.wikipedia.org/wiki/Geriatrics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3399",
                            "term": "Geriatrics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3305",
                            "term": "https://en.wikipedia.org/wiki/Public_health"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3305",
                            "term": "https://en.wikipedia.org/wiki/Epidemiology"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0560",
                                    "term": "DNA vaccine design"
                                }
                            ],
                            []
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Serostatus testing and dengue vaccine cost-benefit thresholds | R package for manuscript \"Serostatus Testing & Dengue Vaccine Cost Benefit Thresholds\"",
                "homepage": "https://cran.r-project.org/web/packages/denvax/index.html"
            }
        ],
        "inputs": [
            "meta",
            "fasta",
            "vs2_db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/virsorter'"
        ],
        "when": "",
        "stub": ""
    },
    "VIRFINDER": {
        "name_process": "VIRFINDER",
        "string_process": "\nprocess VIRFINDER {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    \n    container 'nakor/virfinder'\n\n    input:\n    tuple val(meta), path(fasta)\n    val options\n\n    output:\n    tuple val(meta), path('virfinder_annot*.csv'), emit: all\n    tuple val(meta), path(\"virfinder-${meta.id}.txt\"), emit: ctg_ids\n    \n    script:\n    def ioptions = initOptions(options)\n    \"\"\"\n    #!/usr/bin/env Rscript\n\n    source(\"/opt/R/virfinder.R\")\n\n    result <- parVF.pred(\"${fasta}\", cores=$task.cpus)\n\n    write.csv(result, 'virfinder_annot_${meta.id}.csv', quote=F)\n    write(rownames(result)[result\\$pvalue<${params.virfinder_thresh}], 'virfinder-${meta.id}.txt')\n    \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "    def ioptions = initOptions(options)\n    \"\"\"\n    #!/usr/bin/env Rscript\n\n    source(\"/opt/R/virfinder.R\")\n\n    result <- parVF.pred(\"${fasta}\", cores=$task.cpus)\n\n    write.csv(result, 'virfinder_annot_${meta.id}.csv', quote=F)\n    write(rownames(result)[result\\$pvalue<${params.virfinder_thresh}], 'virfinder-${meta.id}.txt')\n    \"\"\"",
        "nb_lignes_script": 10,
        "language_script": "Rscript",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "options"
        ],
        "nb_inputs": 3,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/virfinder'"
        ],
        "when": "",
        "stub": ""
    },
    "VIRALVERIFY_DB": {
        "name_process": "VIRALVERIFY_DB",
        "string_process": "\nprocess VIRALVERIFY_DB {\n    label 'process_low'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    \n    container 'nakor/virus_extraction'\n    \n    output:\n    file('Pfam-A.hmm')\n\n    script:\n    \"\"\"\n    wget ftp://ftp.ebi.ac.uk/pub/databases/Pfam/releases/Pfam33.1/Pfam-A.hmm.gz \n    unpigz -p $task.cpus Pfam-A.hmm.gz\n    \"\"\"\n}",
        "nb_lignes_process": 16,
        "string_script": "    \"\"\"\n    wget ftp://ftp.ebi.ac.uk/pub/databases/Pfam/releases/Pfam33.1/Pfam-A.hmm.gz \n    unpigz -p $task.cpus Pfam-A.hmm.gz\n    \"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [],
        "nb_inputs": 0,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "label 'process_low'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/virus_extraction'"
        ],
        "when": "",
        "stub": ""
    },
    "VIRALVERIFY": {
        "name_process": "VIRALVERIFY",
        "string_process": "\nprocess VIRALVERIFY {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }\n    container 'nakor/virus_extraction'\n    \n\tinput:\n    tuple val(meta), path(fasta)\n    path pfam_db\n    val options\n\n\toutput:\n    tuple val(meta), path('Prediction_results_fasta/*'), emit: all\n    tuple val(meta), path(\"viralverify-${meta.id}.txt\"), emit: ctg_ids\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    viralverify.py $ioptions.args -f ${fasta} -o ./ --hmm ${pfam_db} -t $task.cpus\n    cat Prediction_results_fasta/*virus* | grep '^>' | cut -c2- > viralverify-${prefix}.txt\n\n    echo -1 > ${software}.version.txt # No version yet\n    \"\"\"\n}",
        "nb_lignes_process": 27,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    viralverify.py $ioptions.args -f ${fasta} -o ./ --hmm ${pfam_db} -t $task.cpus\n    cat Prediction_results_fasta/*virus* | grep '^>' | cut -c2- > viralverify-${prefix}.txt\n\n    echo -1 > ${software}.version.txt # No version yet\n    \"\"\"",
        "nb_lignes_script": 8,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "pfam_db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:\"\") }",
            "container 'nakor/virus_extraction'"
        ],
        "when": "",
        "stub": ""
    },
    "TAXONKIT_LINEAGE": {
        "name_process": "TAXONKIT_LINEAGE",
        "string_process": "\nprocess TAXONKIT_LINEAGE {\n    tag \"$meta.id\"\n    label 'process_medium'\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n\n    container \"quay.io/biocontainers/taxonkit:0.6.0--0\"\n    conda (params.conda ? \"bioconda::taxonkit=0.6.0\" : null)\n\n    input:\n    tuple val(meta), path(taxids)\n    path db\n    val options\n\n    output:\n    tuple val(meta), path(\"*.txt\"), emit: txt\n    path \"*.version.txt\", emit: version\n\n    script:\n    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    taxonkit lineage $ioptions.args -r $taxids \\\\\n        --data-dir $db \\\\\n        --threads $task.cpus \\\\\n        > ${prefix}-lineages.txt\n\n    taxonkit version | sed 's/taxonkit //'  > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 31,
        "string_script": "    def software = getSoftwareName(task.process)\n    def ioptions = initOptions(options)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n    \"\"\"\n    taxonkit lineage $ioptions.args -r $taxids \\\\\n        --data-dir $db \\\\\n        --threads $task.cpus \\\\\n        > ${prefix}-lineages.txt\n\n    taxonkit version | sed 's/taxonkit //'  > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 10,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "taxids",
            "db",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag \"$meta.id\"",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container \"quay.io/biocontainers/taxonkit:0.6.0--0\"",
            "conda (params.conda ? \"bioconda::taxonkit=0.6.0\" : null)"
        ],
        "when": "",
        "stub": ""
    },
    "COCONET_PREPROCESS": {
        "name_process": "COCONET_PREPROCESS",
        "string_process": "\nprocess COCONET_PREPROCESS {\n    tag {\"${meta.id}\"}\n    label 'process_medium'\n\n    publishDir \"${params.outdir}\",\n        mode: params.publish_dir_mode,\n        saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }\n\n    container 'nakor/coconet'\n                                                  \n                                                                     \n    \n    input:\n    tuple val(meta), file(fasta), file(coverage)\n    val options\n\n    output:\n    tuple val(meta), path(\"output/*.fasta\"), emit: fasta\n    tuple val(meta), path(\"output/*.h5\"), emit: h5\n    tuple val(meta), path(\"output/*.log\"), emit: log\n    path \"*.version.txt\", emit: version\n\n    script:\n    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n\n    def cov_list = coverage instanceof List ? coverage : [coverage]\n    def cov_flag = cov_list[0].getExtension() == 'bam' ? \"--bam\" : \"--h5\"\n    \"\"\"\n    coconet preprocess $ioptions.args \\\\\n        --fasta $fasta \\\\\n        $cov_flag ${cov_list.join(' ')} \\\\\n        --output output \\\\\n        --thread $task.cpus\n\n    coconet --version > ${software}.version.txt\n    \"\"\"\n}",
        "nb_lignes_process": 38,
        "string_script": "    def ioptions = initOptions(options)\n    def software = getSoftwareName(task.process)\n    def prefix   = ioptions.suffix ? \"${meta.id}${ioptions.suffix}\" : \"${meta.id}\"\n\n    def cov_list = coverage instanceof List ? coverage : [coverage]\n    def cov_flag = cov_list[0].getExtension() == 'bam' ? \"--bam\" : \"--h5\"\n    \"\"\"\n    coconet preprocess $ioptions.args \\\\\n        --fasta $fasta \\\\\n        $cov_flag ${cov_list.join(' ')} \\\\\n        --output output \\\\\n        --thread $task.cpus\n\n    coconet --version > ${software}.version.txt\n    \"\"\"",
        "nb_lignes_script": 14,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "meta",
            "fasta",
            "coverage",
            "options"
        ],
        "nb_inputs": 4,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "Puumanamana__nf-modules",
        "directive": [
            "tag {\"${meta.id}\"}",
            "label 'process_medium'",
            "publishDir \"${params.outdir}\" , mode: params.publish_dir_mode , saveAs: { filename -> saveFiles(filename:filename, options:options, publish_dir:getSoftwareName(task.process), publish_id:meta.id) }",
            "container 'nakor/coconet'"
        ],
        "when": "",
        "stub": ""
    }
}