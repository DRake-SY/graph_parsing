{
    "getReadLength": {
        "name_process": "getReadLength",
        "string_process": "\nprocess getReadLength {\n    input:\n    file(single_read_pairs) from read_files_for_size.first()\n\n    output:\n    stdout into (read_length_for_merging)\n\n\tscript:\n\tdef qc = new QualityChecker(input:single_read_pairs)\n\tqc.getReadSize()\n}",
        "nb_lignes_process": 10,
        "string_script": "\tdef qc = new QualityChecker(input:single_read_pairs)\n\tqc.getReadSize()",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "read_files_for_size"
        ],
        "nb_inputs": 1,
        "outputs": [
            ""
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "raw_fastqc": {
        "name_process": "raw_fastqc",
        "string_process": "\nprocess raw_fastqc {\n    tag \"$read\"\n    publishDir outputQC, mode: 'copy', pattern: '*fastqc*'\n\n    afterScript 'mv *_fastqc.zip `basename *_fastqc.zip _fastqc.zip`_raw_fastqc.zip'\n\n    input:\n    file(read) from reads_for_fastqc\n\n    output:\n    file(\"*_fastqc.zip\") into raw_fastqc_files\n\n    script:\n    def qc = new QualityChecker(input:read, cpus:task.cpus)\n    qc.fastqc()\n}",
        "nb_lignes_process": 15,
        "string_script": "    def qc = new QualityChecker(input:read, cpus:task.cpus)\n    qc.fastqc()",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "reads_for_fastqc"
        ],
        "nb_inputs": 1,
        "outputs": [
            "raw_fastqc_files"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$read\"",
            "publishDir outputQC, mode: 'copy', pattern: '*fastqc*'",
            "afterScript 'mv *_fastqc.zip `basename *_fastqc.zip _fastqc.zip`_raw_fastqc.zip'"
        ],
        "when": "",
        "stub": ""
    },
    "trimReads": {
        "name_process": "trimReads",
        "string_process": "\nprocess trimReads {\n    tag \"$pair_id\"\n    afterScript 'mv *-trimmed-pair1* `echo *-trimmed-pair1* | sed s/\\\\-trimmed\\\\-pair1/_1_filt/g`; mv *-trimmed-pair2* `echo *-trimmed-pair2* | sed s/\\\\-trimmed\\\\-pair2/_2_filt/g`'\n         \n    input:\n    set pair_id, file(reads) from (read_files_for_trimming)\n\n    output:\n    set pair_id, file(\"*_filt.fastq.gz\") into filtered_reads_for_assembly\n    file(\"*_filt.fastq.gz\") into filtered_read_for_QC\n    file(\"*trimmed.log\") into logTrimming_for_QC\n\n    script:    \n    def trimmer = new Trimmer(reads:reads, extrapars:\"-Q ${params.meanquality} -q ${params.trimquality} -x ${params.adapter}\", id:pair_id, min_read_size:params.minsize, cpus:task.cpus)\n    trimmer.trimWithSkewer()\n}",
        "nb_lignes_process": 15,
        "string_script": "    def trimmer = new Trimmer(reads:reads, extrapars:\"-Q ${params.meanquality} -q ${params.trimquality} -x ${params.adapter}\", id:pair_id, min_read_size:params.minsize, cpus:task.cpus)\n    trimmer.trimWithSkewer()",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "read_files_for_trimming"
        ],
        "nb_inputs": 1,
        "outputs": [
            "filtered_reads_for_assembly",
            "filtered_read_for_QC",
            "logTrimming_for_QC"
        ],
        "nb_outputs": 3,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "afterScript 'mv *-trimmed-pair1* `echo *-trimmed-pair1* | sed s/ -trimmed -pair1/_1_filt/g`; mv *-trimmed-pair2* `echo *-trimmed-pair2* | sed s/ -trimmed -pair2/_2_filt/g`'"
        ],
        "when": "",
        "stub": ""
    },
    "trimmedQC": {
        "name_process": "trimmedQC",
        "string_process": "\nprocess trimmedQC {\n    tag \"$filtered_read\"\n    publishDir outputQC, mode: 'copy', pattern: '*fastqc*'\n\n                                                                                       \n\n    input:\n    file(filtered_read) from filtered_read_for_QC.flatten()\n\n    output:\n    file(\"*_fastqc.zip\") into trimmed_fastqc_files\n\n    script:\n    def qc = new QualityChecker(input:filtered_read, cpus:task.cpus)\n    qc.fastqc()\n}",
        "nb_lignes_process": 15,
        "string_script": "    def qc = new QualityChecker(input:filtered_read, cpus:task.cpus)\n    qc.fastqc()",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "filtered_read_for_QC"
        ],
        "nb_inputs": 1,
        "outputs": [
            "trimmed_fastqc_files"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$filtered_read\"",
            "publishDir outputQC, mode: 'copy', pattern: '*fastqc*'"
        ],
        "when": "",
        "stub": ""
    },
    "assemble": {
        "name_process": "assemble",
        "string_process": "\nprocess assemble {\n    tag \"$pair_id\"\n    publishDir outputAssembly, mode: 'copy', pattern: '*_assembly.fa'\n\n    label 'big_mem_cpus'\n\n    input:\n    set pair_id, file(readsA), file(readsB) from  filtered_reads_for_assembly.flatten().collate( 3 )\n    val read_size from read_length_for_merging.map { it.trim().toInteger() }\n\n    output:\n    set pair_id, file(\"${pair_id}_assembly.fa\"), file(\"${pair_id}/spades.log\") into scaffold_for_evaluation\n\n    script:\n\n    if( params.merge)\n    \"\"\"\n       flash -t ${task.cpus} -o joint_reads -m 50 -M ${read_size} ${readsA} ${readsB}\n       spades.py --phred-offset 33 --cov-cutoff auto --careful -s joint_reads.extendedFrags.fastq -o ${pair_id} -t ${task.cpus} -m ${task.memory.giga} \n       cp ${pair_id}/scaffolds.fasta ${pair_id}_assembly.fa\n    \"\"\"\n    else \n    \"\"\"\n       spades.py --phred-offset 33 --cov-cutoff auto --careful --pe1-1 ${readsA} --pe1-2 ${readsB} -o ${pair_id} -t ${task.cpus} -m ${task.memory.giga} \n       cp ${pair_id}/scaffolds.fasta ${pair_id}_assembly.fa\n    \"\"\"\n}",
        "nb_lignes_process": 26,
        "string_script": "    if( params.merge)\n    \"\"\"\n       flash -t ${task.cpus} -o joint_reads -m 50 -M ${read_size} ${readsA} ${readsB}\n       spades.py --phred-offset 33 --cov-cutoff auto --careful -s joint_reads.extendedFrags.fastq -o ${pair_id} -t ${task.cpus} -m ${task.memory.giga} \n       cp ${pair_id}/scaffolds.fasta ${pair_id}_assembly.fa\n    \"\"\"\n    else \n    \"\"\"\n       spades.py --phred-offset 33 --cov-cutoff auto --careful --pe1-1 ${readsA} --pe1-2 ${readsB} -o ${pair_id} -t ${task.cpus} -m ${task.memory.giga} \n       cp ${pair_id}/scaffolds.fasta ${pair_id}_assembly.fa\n    \"\"\"",
        "nb_lignes_script": 10,
        "language_script": "bash",
        "tools": [
            "FLASH"
        ],
        "tools_url": [
            "https://bio.tools/flash"
        ],
        "tools_dico": [
            {
                "name": "FLASH",
                "uri": "https://bio.tools/flash",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0196",
                            "term": "Sequence assembly"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "Sequencing"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "DNA-Seq"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3219",
                                    "term": "Read pre-processing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0310",
                                    "term": "Sequence assembly"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0232",
                                    "term": "Sequence merging"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3219",
                                    "term": "Sequence read pre-processing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0232",
                                    "term": "Sequence splicing"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "Identifies paired-end reads which overlap in the middle, converting them to single long reads",
                "homepage": "http://ccb.jhu.edu/software/FLASH/"
            }
        ],
        "inputs": [
            "filtered_reads_for_assembly",
            "read_length_for_merging"
        ],
        "nb_inputs": 2,
        "outputs": [
            "scaffold_for_evaluation"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "publishDir outputAssembly, mode: 'copy', pattern: '*_assembly.fa'",
            "label 'big_mem_cpus'"
        ],
        "when": "",
        "stub": ""
    },
    "evaluateAssembly": {
        "name_process": "evaluateAssembly",
        "string_process": " process evaluateAssembly {\n   publishDir outputRefAssembly, mode: 'copy', pattern: '*_assembly_ev.fa'\n   tag \"$pair_id\"\n    \n    echo true\n    label 'big_mem_cpus'\n\n    input:\n    set pair_id, file(scaffolds), file(log_assembly) from  scaffold_for_evaluation\n    \n    output:\n    set pair_id, file(\"${pair_id}_assembly_ev.fa\") into scaffold_file_for_blast, scaffold_file_for_re, scaffold_file_for_parsing, scaffold_file_for_variants\n    set pair_id, file(\"${pair_id}_assembly_ev.fa.log\") into log_assembly_for_report  \n\n    script:\n    \"\"\"\n        kmer=`grep \"Used k-mer sizes\" ${log_assembly} | awk '{print \\$NF}'`\n        evaluateAssembly.py -i ${scaffolds} -o ${pair_id}_assembly_ev.fa -n ${pair_id} -k \\$kmer\n    \"\"\"\n}",
        "nb_lignes_process": 18,
        "string_script": "    \"\"\"\n        kmer=`grep \"Used k-mer sizes\" ${log_assembly} | awk '{print \\$NF}'`\n        evaluateAssembly.py -i ${scaffolds} -o ${pair_id}_assembly_ev.fa -n ${pair_id} -k \\$kmer\n    \"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "scaffold_for_evaluation"
        ],
        "nb_inputs": 1,
        "outputs": [
            "scaffold_file_for_blast",
            "scaffold_file_for_re",
            "scaffold_file_for_parsing",
            "scaffold_file_for_variants",
            "log_assembly_for_report"
        ],
        "nb_outputs": 5,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "publishDir outputRefAssembly, mode: 'copy', pattern: '*_assembly_ev.fa'",
            "tag \"$pair_id\"",
            "echo true",
            "label 'big_mem_cpus'"
        ],
        "when": "",
        "stub": ""
    },
    "prepareDB": {
        "name_process": "prepareDB",
        "string_process": "\nprocess prepareDB {\n    tag \"$params.inserts\"\n\n    when:\n    params.inserts\n\n    input:\n    file(features_file) from featuresdb\n    file(inserts_file)\n    \n    output:\n    file(\"whole_db_pipe.fasta\") into whole_db_fasta\n    \n    \"\"\"\n        parseInserts.py -i ${inserts_file} -o  whole_db_pipe.fasta\n        if [ `echo ${features_file} | grep \".gz\"` ]; then \n            zcat ${features_file} >> whole_db_pipe.fasta\n        else \n            cat zcat ${features_file} >> whole_db_pipe.fasta\n        fi\n    \"\"\"\n\n}",
        "nb_lignes_process": 22,
        "string_script": "\"\"\"\n        parseInserts.py -i ${inserts_file} -o  whole_db_pipe.fasta\n        if [ `echo ${features_file} | grep \".gz\"` ]; then \n            zcat ${features_file} >> whole_db_pipe.fasta\n        else \n            cat zcat ${features_file} >> whole_db_pipe.fasta\n        fi\n    \"\"\"",
        "nb_lignes_script": 7,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "featuresdb",
            "inserts_file"
        ],
        "nb_inputs": 2,
        "outputs": [
            "whole_db_fasta"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$params.inserts\""
        ],
        "when": "params.inserts",
        "stub": ""
    },
    "makeBlastDB": {
        "name_process": "makeBlastDB",
        "string_process": "\nprocess makeBlastDB {\n    tag \"$features_file\"\n    \n    input:\n    file(features_file) from (params.inserts ? whole_db_fasta : featuresdb)\n\n    output:\n    set \"blast_db.fasta\", file(\"blast_db.fasta*\") into blastdb_files\n\n    script:\n    def aligner = new NGSaligner(reference_file:features_file, index:\"blast_db.fasta\", dbtype:\"nucl\")\n    aligner.doIndexing(\"blast\")\n}",
        "nb_lignes_process": 12,
        "string_script": "    def aligner = new NGSaligner(reference_file:features_file, index:\"blast_db.fasta\", dbtype:\"nucl\")\n    aligner.doIndexing(\"blast\")",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "params"
        ],
        "nb_inputs": 1,
        "outputs": [
            "blastdb_files"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$features_file\""
        ],
        "when": "",
        "stub": ""
    },
    "runBlast": {
        "name_process": "runBlast",
        "string_process": "\nprocess runBlast {\n    tag \"$pair_id\"\n    publishDir outputBlast\n\n    label 'big_mem_cpus'\n\n    input:\n    set blastname, file(blastdbs) from blastdb_files\n    set pair_id, file(scaffold_file) from scaffold_file_for_blast\n\n    output:\n    set pair_id, file(\"${pair_id}.blastout\") into blast_out_for_plot\n\n    script:\n    def aligner = new NGSaligner(reads:scaffold_file, output:\"${pair_id}.blastout\", index:\"blast_db.fasta\", cpus:task.cpus, extrapars:\"-outfmt 6 -word_size 11\")\n    aligner.doAlignment(\"blast\")\n}",
        "nb_lignes_process": 16,
        "string_script": "    def aligner = new NGSaligner(reads:scaffold_file, output:\"${pair_id}.blastout\", index:\"blast_db.fasta\", cpus:task.cpus, extrapars:\"-outfmt 6 -word_size 11\")\n    aligner.doAlignment(\"blast\")",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "blastdb_files",
            "scaffold_file_for_blast"
        ],
        "nb_inputs": 2,
        "outputs": [
            "blast_out_for_plot"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "publishDir outputBlast",
            "label 'big_mem_cpus'"
        ],
        "when": "",
        "stub": ""
    },
    "runRestrict": {
        "name_process": "runRestrict",
        "string_process": "\nprocess runRestrict {\n    tag \"$pair_id\"\n    publishDir outputRE\n\n    input:\n    set pair_id, file(scaffold_file) from scaffold_file_for_re\n    file(commonenz)\n\n    output:\n    set pair_id, file(\"${pair_id}.restrict\") into restric_file_for_graph\n\n    script:\n    \"\"\"\n        restrict -sequence ${scaffold_file} -outfile ${pair_id}.restrict -single -auto -enzymes @${commonenz} -plasmid\n    \"\"\"\n}",
        "nb_lignes_process": 15,
        "string_script": "    \"\"\"\n        restrict -sequence ${scaffold_file} -outfile ${pair_id}.restrict -single -auto -enzymes @${commonenz} -plasmid\n    \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [
            "restrict"
        ],
        "tools_url": [
            "https://bio.tools/restrict"
        ],
        "tools_dico": [
            {
                "name": "restrict",
                "uri": "https://bio.tools/restrict",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3511",
                            "term": "Nucleic acid sites, features and motifs"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0431",
                                    "term": "Restriction site recognition"
                                }
                            ],
                            []
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_2887",
                                "term": "Nucleic acid sequence record"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_1276",
                                "term": "Nucleic acid features"
                            }
                        ]
                    }
                ],
                "description": "Report restriction enzyme cleavage sites in a nucleotide sequence.",
                "homepage": "http://emboss.open-bio.org/rel/rel6/apps/restrict.html"
            }
        ],
        "inputs": [
            "scaffold_file_for_re",
            "commonenz"
        ],
        "nb_inputs": 2,
        "outputs": [
            "restric_file_for_graph"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "publishDir outputRE"
        ],
        "when": "",
        "stub": ""
    },
    "makePlot": {
        "name_process": "makePlot",
        "string_process": "\nprocess makePlot {\n    tag \"$pair_id\"\n    publishDir outputPlot, mode: 'copy', pattern: '*.svg' \n    publishDir outputGBK, mode: 'copy', pattern: '*.gbk'\n\n    input:\n    set pair_id, file(blastout), file(resites), file(scaffold) from blast_out_for_plot.join(restric_file_for_graph).join(scaffold_file_for_parsing)\n\n    output:\n    set pair_id, file(\"${pair_id}.log\") into log_insert_for_report  \n    file(\"${pair_id}.svg\") \n    file(\"${pair_id}.gbk\") \n\n    script:\n    \"\"\"\n        parse.py -n ${pair_id} -b ${blastout} -f ${scaffold} -o ${pair_id} -r ${resites}\n        \\$CGVIEW -i ${pair_id}.xml  -x true -f svg -o ${pair_id}.svg\n    \"\"\"\n}",
        "nb_lignes_process": 18,
        "string_script": "    \"\"\"\n        parse.py -n ${pair_id} -b ${blastout} -f ${scaffold} -o ${pair_id} -r ${resites}\n        \\$CGVIEW -i ${pair_id}.xml  -x true -f svg -o ${pair_id}.svg\n    \"\"\"",
        "nb_lignes_script": 3,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "blast_out_for_plot",
            "restric_file_for_graph",
            "scaffold_file_for_parsing"
        ],
        "nb_inputs": 3,
        "outputs": [
            "log_insert_for_report"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "publishDir outputPlot, mode: 'copy', pattern: '*.svg'",
            "publishDir outputGBK, mode: 'copy', pattern: '*.gbk'"
        ],
        "when": "",
        "stub": ""
    },
    "callVariants": {
        "name_process": "callVariants",
        "string_process": "\nprocess callVariants {\n    tag \"$pair_id\"\n    publishDir outputVariants\n\n    when: \n    references\n    \n    input:\n    set pair_id, file(scaffold_file), file (reference_file) from scaffold_file_for_variants.join(references)\n\n    output:\n    file(\"${pair_id}.vcf\")\n\n    script:\n    \"\"\"\n        bwa index ${reference_file}\n\t\tbwa mem ${reference_file} ${scaffold_file} | samtools view -Sb - > aln.bam\n\t\tsamtools sort aln.bam -o ${pair_id}.bam \n\t\trm aln.bam\n\t\tbcftools mpileup -Ou -f ${reference_file} ${pair_id}.bam  | bcftools call --ploidy 1 -mv -Ov -o ${pair_id}.vcf\n    \"\"\"\n}",
        "nb_lignes_process": 21,
        "string_script": "    \"\"\"\n        bwa index ${reference_file}\n\t\tbwa mem ${reference_file} ${scaffold_file} | samtools view -Sb - > aln.bam\n\t\tsamtools sort aln.bam -o ${pair_id}.bam \n\t\trm aln.bam\n\t\tbcftools mpileup -Ou -f ${reference_file} ${pair_id}.bam  | bcftools call --ploidy 1 -mv -Ov -o ${pair_id}.vcf\n    \"\"\"",
        "nb_lignes_script": 6,
        "language_script": "bash",
        "tools": [
            "BWA",
            "SAMtools",
            "BCFtools"
        ],
        "tools_url": [
            "https://bio.tools/bwa",
            "https://bio.tools/samtools",
            "https://bio.tools/bcftools"
        ],
        "tools_dico": [
            {
                "name": "BWA",
                "uri": "https://bio.tools/bwa",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        }
                    ],
                    []
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3211",
                                    "term": "Genome indexing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3429",
                                    "term": "Generation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Read mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0292",
                                    "term": "Sequence alignment"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3429",
                                    "term": "Construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Oligonucleotide mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Read alignment"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Oligonucleotide alignment construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Short read mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Oligonucleotide alignment generation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Short oligonucleotide alignment"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Oligonucleotide alignment"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Short sequence read mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3198",
                                    "term": "Short read alignment"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0292",
                                    "term": "Sequence alignment generation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0292",
                                    "term": "Sequence alignment construction"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_2044",
                                "term": "Sequence"
                            },
                            {
                                "uri": "http://edamontology.org/data_3210",
                                "term": "Genome index"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_0863",
                                "term": "Sequence alignment"
                            },
                            {
                                "uri": "http://edamontology.org/data_2012",
                                "term": "Sequence coordinates"
                            },
                            {
                                "uri": "http://edamontology.org/data_1916",
                                "term": "Alignment"
                            },
                            {
                                "uri": "http://edamontology.org/data_3210",
                                "term": "Genome index"
                            }
                        ]
                    }
                ],
                "description": "Fast, accurate, memory-efficient aligner for short and long sequencing reads",
                "homepage": "http://bio-bwa.sourceforge.net"
            },
            {
                "name": "SAMtools",
                "uri": "https://bio.tools/samtools",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "Sequencing"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3325",
                            "term": "Rare diseases"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequence analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_3168",
                            "term": "DNA-Seq"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3325",
                            "term": "https://en.wikipedia.org/wiki/Rare_disease"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0080",
                            "term": "Sequences"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_3096",
                                    "term": "Editing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Visualisation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_1812",
                                    "term": "Parsing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "Formatting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0227",
                                    "term": "Indexing"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Data visualisation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0337",
                                    "term": "Rendering"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_1812",
                                    "term": "Data loading"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_1812",
                                    "term": "Loading"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "Format conversion"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "File reformatting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "File format conversion"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "File formatting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0335",
                                    "term": "Reformatting"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0227",
                                    "term": "Data indexing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0227",
                                    "term": "Database indexing"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_0924",
                                "term": "Sequence trace"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_0924",
                                "term": "Sequence trace"
                            }
                        ]
                    }
                ],
                "description": "A software package with various utilities for processing alignments in the SAM format, including variant calling and alignment viewing.",
                "homepage": "http://www.htslib.org/"
            },
            {
                "name": "BCFtools",
                "uri": "https://bio.tools/bcftools",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3516",
                            "term": "Genotyping experiment"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0199",
                            "term": "Genetic variation"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3517",
                            "term": "GWAS study"
                        },
                        {
                            "uri": "http://edamontology.org/topic_2885",
                            "term": "DNA polymorphism"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0199",
                            "term": "DNA variation"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3517",
                            "term": "GWAS analysis"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3517",
                            "term": "GWAS"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3517",
                            "term": "Genome-wide association study"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2409",
                                    "term": "Data handling"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3227",
                                    "term": "Variant calling"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_2409",
                                    "term": "Utility operation"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2409",
                                    "term": "File handling"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2409",
                                    "term": "File processing"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_2409",
                                    "term": "Report handling"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_3227",
                                    "term": "Variant mapping"
                                }
                            ]
                        ],
                        "input": [
                            {
                                "uri": "http://edamontology.org/data_3498",
                                "term": "Sequence variations"
                            }
                        ],
                        "output": [
                            {
                                "uri": "http://edamontology.org/data_3498",
                                "term": "Sequence variations"
                            }
                        ]
                    }
                ],
                "description": "Set of utilities that manipulate variant calls in the Variant Call Format (VCF) and its binary counterpart BCF. All commands work transparently with both VCFs and BCFs, both uncompressed and BGZF-compressed.",
                "homepage": "http://www.htslib.org/"
            }
        ],
        "inputs": [
            "scaffold_file_for_variants",
            "references"
        ],
        "nb_inputs": 2,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\"",
            "publishDir outputVariants"
        ],
        "when": "references",
        "stub": ""
    },
    "makePipeReport": {
        "name_process": "makePipeReport",
        "string_process": "\nprocess makePipeReport {\n    tag \"$pair_id\"\n\n    input:\n    set pair_id, file(insert), file(assembly) from log_insert_for_report.join(log_assembly_for_report)\n\n    output:\n    file(\"${pair_id}_repo.txt\") into pipe_report_for_join\n        \n    script:\n    \"\"\"\n        paste ${assembly} ${insert} > ${pair_id}_repo.txt\n    \"\"\"\n}",
        "nb_lignes_process": 13,
        "string_script": "    \"\"\"\n        paste ${assembly} ${insert} > ${pair_id}_repo.txt\n    \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "log_insert_for_report",
            "log_assembly_for_report"
        ],
        "nb_inputs": 2,
        "outputs": [
            "pipe_report_for_join"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag \"$pair_id\""
        ],
        "when": "",
        "stub": ""
    },
    "makePipeMultiQCReport": {
        "name_process": "makePipeMultiQCReport",
        "string_process": "\nprocess makePipeMultiQCReport {\n    input:\n    file(\"report*\") from pipe_report_for_join.collect()\n\n    output:\n    file(\"vectorQC_mqc.txt\") into pipe_report_for_multiQC \n        \n    script:\n    \"\"\"\n    echo \"# plot_type: 'table'\n# section_name: 'vectorQC'\n# description: 'Results of the vectorQC pipeline. Number of contigs found, total size and inserted genes found'\n# pconfig:\n#     namespace: 'vectorQC'\n# headers:\n#     col1:\n#         title: 'Sample'\n#     col2:\n#          title: '# of scaffolds'             \n#          format: '{:,.0f}'\n#     col3:\n#          title: 'Size'\n#          format: '{:,.0f}'\n#     col4:\n#          title: 'Insert(s) found'\nSample    col2    col3    col4\n\" > vectorQC_mqc.txt\n        cat report* >> vectorQC_mqc.txt\n    \"\"\"\n}",
        "nb_lignes_process": 29,
        "string_script": "    \"\"\"\n    echo \"# plot_type: 'table'\n# section_name: 'vectorQC'\n# description: 'Results of the vectorQC pipeline. Number of contigs found, total size and inserted genes found'\n# pconfig:\n#     namespace: 'vectorQC'\n# headers:\n#     col1:\n#         title: 'Sample'\n#     col2:\n#          title: '# of scaffolds'             \n#          format: '{:,.0f}'\n#     col3:\n#          title: 'Size'\n#          format: '{:,.0f}'\n#     col4:\n#          title: 'Insert(s) found'\nSample    col2    col3    col4\n\" > vectorQC_mqc.txt\n        cat report* >> vectorQC_mqc.txt\n    \"\"\"",
        "nb_lignes_script": 20,
        "language_script": "bash",
        "tools": [
            "SAMPLE"
        ],
        "tools_url": [
            "https://bio.tools/sample"
        ],
        "tools_dico": [
            {
                "name": "SAMPLE",
                "uri": "https://bio.tools/sample",
                "topic": [
                    [
                        {
                            "uri": "http://edamontology.org/topic_3516",
                            "term": "Genotyping experiment"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0102",
                            "term": "Mapping"
                        },
                        {
                            "uri": "http://edamontology.org/topic_3053",
                            "term": "Genetics"
                        },
                        {
                            "uri": "http://edamontology.org/topic_0654",
                            "term": "DNA"
                        }
                    ],
                    [
                        {
                            "uri": "http://edamontology.org/topic_0654",
                            "term": "DNA analysis"
                        }
                    ]
                ],
                "function": [
                    {
                        "operation": [
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Genetic mapping"
                                }
                            ],
                            [
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Genetic map construction"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Linkage mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Functional mapping"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Genetic cartography"
                                },
                                {
                                    "uri": "http://edamontology.org/operation_0282",
                                    "term": "Genetic map generation"
                                }
                            ]
                        ],
                        "input": [],
                        "output": []
                    }
                ],
                "description": "The tool is designed to identify regions that are linked to a recessive disease by analysing genotype data from the parents and unaffected sibs of affected individuals. Since this analysis does not use data from affected patients, it is suited to the identification of lethal recessive genes, when the patients may have died before DNA samples could be obtained.",
                "homepage": "http://dna.leeds.ac.uk/sample/"
            }
        ],
        "inputs": [
            "pipe_report_for_join"
        ],
        "nb_inputs": 1,
        "outputs": [
            "pipe_report_for_multiQC"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "tool_report": {
        "name_process": "tool_report",
        "string_process": "\nprocess tool_report {\n\n    input:\n    file(tooldb)\n\n    output:\n    file(\"tools_mqc.txt\") into tool_report_for_multiQC \n        \n    script:\n    \"\"\"\n         make_tool_desc_for_multiqc.pl -c ${tooldb} -l fastqc,skewer,spades,blast,cgview,emboss,samtools,bcftools,bwa > tools_mqc.txt\n    \"\"\"\n}",
        "nb_lignes_process": 12,
        "string_script": "    \"\"\"\n         make_tool_desc_for_multiqc.pl -c ${tooldb} -l fastqc,skewer,spades,blast,cgview,emboss,samtools,bcftools,bwa > tools_mqc.txt\n    \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "tooldb"
        ],
        "nb_inputs": 1,
        "outputs": [
            "tool_report_for_multiQC"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [],
        "when": "",
        "stub": ""
    },
    "multiQC": {
        "name_process": "multiQC",
        "string_process": "\nprocess multiQC {\n    publishDir outputMultiQC, mode: 'copy'\n\n    input:\n    file (\"*\") from raw_fastqc_files.mix(logTrimming_for_QC,trimmed_fastqc_files).flatten().collect()\n    file 'pre_config.yaml.txt' from multiconfig\n    file (tool_report_for_multiQC)\n    file (pipe_report_for_multiQC)\n    file (logo_vectorQC)\n\n    output:\n    file(\"multiqc_report.html\") into multiQC \n    \n    script:\n    def reporter = new Reporter(title:\"VectorQC screening\", application:\"Mi-seq\", subtitle:\"\", id:\"vectors\", email:params.email, config_file:\"pre_config.yaml.txt\")\n    reporter.makeMultiQCreport()\n}",
        "nb_lignes_process": 16,
        "string_script": "    def reporter = new Reporter(title:\"VectorQC screening\", application:\"Mi-seq\", subtitle:\"\", id:\"vectors\", email:params.email, config_file:\"pre_config.yaml.txt\")\n    reporter.makeMultiQCreport()",
        "nb_lignes_script": 1,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "raw_fastqc_files",
            "logTrimming_for_QC",
            "trimmed_fastqc_files",
            "multiconfig",
            "tool_report_for_multiQC",
            "pipe_report_for_multiQC",
            "logo_vectorQC"
        ],
        "nb_inputs": 7,
        "outputs": [
            "multiQC"
        ],
        "nb_outputs": 1,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "publishDir outputMultiQC, mode: 'copy'"
        ],
        "when": "",
        "stub": ""
    },
    "simulateVectors": {
        "name_process": "simulateVectors",
        "string_process": "\nprocess simulateVectors {\n    tag { sequence }\n    publishDir params.output, mode: 'copy'\n\n    input:\n    set id, file(sequence) from sequences\n\n    output:\n    file(\"*.fq\") \n\n    script:\n    \"\"\"\n        simulateCircular.py -i ${sequence} -o ${id} -x ${params.fold} -d ${params.outerd} -e ${params.stdev} -s ${params.size}\n    \"\"\"\n}",
        "nb_lignes_process": 14,
        "string_script": "    \"\"\"\n        simulateCircular.py -i ${sequence} -o ${id} -x ${params.fold} -d ${params.outerd} -e ${params.stdev} -s ${params.size}\n    \"\"\"",
        "nb_lignes_script": 2,
        "language_script": "bash",
        "tools": [],
        "tools_url": [],
        "tools_dico": [],
        "inputs": [
            "sequences"
        ],
        "nb_inputs": 1,
        "outputs": [],
        "nb_outputs": 0,
        "name_workflow": "biocorecrg__vectorQC",
        "directive": [
            "tag { sequence }",
            "publishDir params.output, mode: 'copy'"
        ],
        "when": "",
        "stub": ""
    }
}